
\documentclass[12pt]{JHEP3}
\usepackage{epsfig,amsfonts,amssymb,amsmath} 
 
%\setlength{\topmargin}{.5cm}
%\setlength{\textheight}{23.1cm}Denef
\setlength{\textwidth}{14.5cm}
%\setlength{\evensidemargin}{2.4cm}
%\setlength{\oddsidemargin}{2.4cm} 
% \renewcommand{\baselinestretch}{1.1}
% 
    \def\CI {{\cal I}}
    \def\CF {{\cal F}}
   
\usepackage{marginnote}
\reversemarginpar
%\newcommand{\newnotea}{ \marginnote{\bf New in v3.1:}[-4mm]}
%\newcommand{\newnoteb}{ \marginnote{\bf New in v2.1:}[-4mm]}
 
 \newcommand{\newnotea}{}
\newcommand{\newnoteb}{}


% from Bourjaily arXiv:1212.6974
%\pdfoutput=1
%\let\ifpdf\relax
\usepackage{color}
\let\normalcolor\relax

\newcommand{\mathematica}[3]{\vspace{0.35cm}\noindent\boxed{\begin{minipage}{#1\textwidth}\begin{tabular}{lp{13cm}}{\color{paper_blue}{\scriptsize{\tt In[1]:}}\raisebox{-0.65pt}{{\scriptsize{\tt=}}}}&{\tt #2}\\{\color{paper_blue}{\scriptsize {\tt Out[1]:}}\raisebox{-0.65pt}{{\scriptsize{\tt=}}}}&{\tt #3}\end{tabular}\end{minipage}}\vspace{0.35cm}}

\definecolor{varcolor}{rgb}{0.1,0.55,0.25}
\definecolor{functioncolor}{rgb}{0.1,0.35,0.75}
\definecolor{paper_blue}{rgb}{0.3,0.2,0.75}
\definecolor{paper_red}{rgb}{0.65,0.1,0.15}
\definecolor{paper_green}{rgb}{0.05,0.35,0.125}
\definecolor{paper_grey}{gray}{0.375}
\definecolor{perm}{rgb}{0.1,0.45,0.85}
\definecolor{deemph}{rgb}{0.7,0.7,0.7}
\setlength{\leftmargini}{21pt}
\newcommand{\vardef}[1]{{\color{varcolor}{\sl #1}\rule[-1.05pt]{7.5pt}{.75pt}}}
\newcommand{\vardefms}[1]{{\color{varcolor}{\sl #1}\rule[-1.05pt]{15pt}{.75pt}}}
\newcommand{\vardefo}[1]{{\color{varcolor}{\sl #1}\rule[-1.05pt]{7.5pt}{.75pt}{\bf{\sl :}}}}
\newcommand{\vardefoo}[1]{{\color{varcolor}{\sl #1}\rule[-1.05pt]{15pt}{.75pt}{\bf{\sl :}}}}
\newcommand{\defn}[3]{~\\[-35pt]\begin{itemize}\item[]\indent\hspace{-21pt}$\bullet$\hspace{-.75pt} {\tt {\color{functioncolor}#1}\![}#2{\tt\,]\!:}#3\end{itemize}\vspace{-7pt}
}
\newcommand{\defnNA}[3]{~\\[-30pt]\begin{itemize}\item[]\indent\hspace{-21pt}$\bullet$\hspace{-.75pt} {\tt {\color{functioncolor}#1}\!}#2{\tt\,\!:}#3\end{itemize}\vspace{-10pt}}
\newcommand{\defntb}[4]{~\\[-30pt]\begin{itemize}\item[]\indent\hspace{-21pt}$\bullet$\hspace{-.75pt} {\tt {\color{functioncolor}#1}\![}#2{\tt\,]\![}#3{\tt\,]\!:}#4\end{itemize}\vspace{-10pt}}
\newcommand{\defvar}[2]{~\\[-30pt]\begin{itemize}\item[]\indent\hspace{-21pt}$\bullet$\hspace{-.75pt} \var{#1}: #2\end{itemize}\vspace{-10pt}}
\newcommand{\var}[1]{{\tt{\color{varcolor}{\tt #1}}}}
\newcommand{\ind}{\hspace{4ex}}
\newcommand{\fun}[1]{{\color{functioncolor}{\tt #1}}}

%%%%%%%%%%%%%%%

\newcommand{\hab}{}



\newcommand{\bZ}{\mathbb{Z}}
\newcommand{\cC}{\mathcal{C}}
\newcommand{\cQ}{\mathcal{Q}}

\newcommand{\IZ}{\mathbb{Z}}
\newcommand{\kk}{k}

\newcommand{\IR}{\mathbb{R}}


\newcommand{\nn}{\nonumber \\}
\newcommand{\be}{\begin{equation}}
\newcommand{\ee}{\end{equation}}
\newcommand{\ben}{\begin{eqnarray}\displaystyle}
\newcommand{\een}{\end{eqnarray}}

\newcommand{\refb}[1]{(\ref{#1})}
\newcommand{\p}{\partial}

\newcommand{\ta}{\tilde\alpha}
\newcommand{\cc}{\tilde c}
\newcommand{\ha}{\hat\alpha}
\newcommand{\dx}{c}

\newcommand\bOm{\bar\Omega}
\newcommand\tOm{\widetilde\Omega}


\newcommand{\cN}{\mathcal{N}}
\newcommand{\cM}{\mathcal{M}}
\newcommand{\gref}{g_{\rm Coulomb}}
\newcommand{\gR}{G_{\rm Higgs}}
\newcommand{\gRa}{g_{\rm Higgs}}
\newcommand{\QR}{Q_{\rm Higgs}}
\newcommand{\bQR}{\bar Q_{\rm Higgs}}
%\newcommand{\QC}{Q_{\rm Coulomb}}
%\newcommand{\bQC}{{\bar Q}_{\rm Coulomb}}

\newcommand{\QC}{\Omega}
\newcommand{\bQC}{\bOm}

\newcommand{\gC}{G_{\rm Coulomb}}
\newcommand{\OmS}{\Omega_{\rm S}} 
\newcommand{\Omatt}{\Omega_*} 
\newcommand{\I}{{\rm i}}
%\newcommand{\eqref}{\refb}

\renewcommand{\theequation}{\thesection.\arabic{equation}}

%\newcommand{\href}[1]{#1}

\def\newdefy{\vardef{y}}

\title{CoulombHiggs.m v6.3}
 
\author{Boris Pioline}

\abstract{Basic documentation for the Mathematica package {\tt CoulombHiggs.m}
available from {\tt http://www.lpthe.jussieu.fr/$\sim$\,pioline/computing.html}
and from  {\tt https://github.com/bpioline/CoulombHiggs}
 }

\begin{document}


\maketitle

\baselineskip 15pt

\tableofcontents

\medskip

\section{Summary}

The  {\sc Mathematica} package {\tt CoulombHiggs.m} provides a suite of routines compute (specializations of) the HodgeÂŽ polynomial 
\be
\label{defOm}
\Omega(\gamma,\zeta,y,t) := 
\sum_{p,q=0}^{d}\, (-y)^{p+q-d} t^{p-q}\, h_{p,q}(\cM_Q)\, 
\ee
of the moduli space $\cM_Q$ of semi-stable representations of a quiver $Q$ with antisymmetric
adjacency matrix $\alpha_{ij}$ (such that $\alpha_{ij}$ counts the net number of arrows $i\to j$, with
arrows $j\to i$ counted negatively),  dimension vector $\gamma=(N_1,\dots, N_K)$ and stability parameters $(\zeta_1,\dots, \zeta_K)$ such that $\sum_i N_i \zeta_i=0$. When $\cM_Q$ is 
a smooth projective variety of complex dimension $d$, \eqref{defOm} is a Laurent polynomial  with integer coefficients, invariant under separate inversions $y\to 1/y, t\to 1/t$. When $\gamma$ is not primitive, it is useful to introduce the {\it rational invariant}
\be
\label{defbOm}
\bOm(\gamma,\zeta,y,t)=\sum_{d|\gamma} \frac{y-1/y}{d(y^d-y^{-d})} \Omega(\gamma/d,\zeta,y^d,t^d)\ee 
which satisfies simpler wall-crossing identities. Finally, $\bOm(\gamma,\zeta,y,t)$ may be expressed 
in terms of the {\it stack invariants} $G_{\rm Higgs}(\gamma,\zeta,y,t)$ defined by \cite[(4.1)]{Manschot:2013sya}
\be
\label{eq:inversestackinv}
\begin{split}
\bOm(\gamma,\zeta,y,t) 
  =& %\sum_\ell 
  \sum_{\{\vec M^{(i)}\} \atop {
  \sum_{i=1}^\ell \vec M^{(i)}=\vec N \atop  \vec M^{(i)}\parallel \vec N
  \,\mathrm{for}\,\, i=1,\dots,\ell}}
\frac{1}{\ell\,(y-1/y)^{\ell-1}}  
%\\& \times 
\prod_{i=1}^\ell 
\gR(\{ M^{(i)}_1, \cdots M^{(i)}_K \};
% \{\gamma_1,\cdots \gamma_K\}; 
\{\zeta_1, \cdots \zeta_K\};y,t)
\, .  
\end{split}
\ee
where $\vec N$ is the dimension vector corresponding to $\gamma$. The stack invariants 
satisfy yet simpler wall-crossing identities, but their physical meaning is less transparent.
Note that they differ from the {\it stacky invariants} by a factor $(1/y-y)$.

\medskip

The package implements the following main formulae:
 \begin{itemize}
 
 \item  the {\it Higgs branch formula} is  based on Reineke's solution to the Harder-Narasimhan recursion \cite{1043.17010} for quivers with primitive dimension vector and no closed loops. 
 The formula apparently also applies to quivers with oriented loops but without superpotential 
 and for non-primitive dimension vector, provided the Hodge numbers $h_{p,q}(\cM_Q)$
 are defined using intersection homology;
 
 \item the {\it Coulomb branch} formula \cite{Manschot:2010qz,Manschot:2011xc,
 Manschot:2012rx,Manschot:2014fua} is based on a physical picture of BPS states as bound states of single-centered black holes; it applies to any quivers with or without oriented loops  and expresses the index in terms
 of `single-centered invariants' $\OmS(\gamma_i,t)$, which are independent of stability conditions,
 and conjecturally depend only on $t$;
 
 \item the {\it Joyce formula}  \cite{joyce2008configurations} expresses the rational invariants $\bOm(\gamma,\zeta_1,y,t)$ in terms of the invariants $\bOm(\gamma_i,\zeta_2,y,t)$, and
 similarly the stack invariants $\gR(\gamma,\zeta_1,y,t)$ in terms of $\gR(\gamma_i,\zeta_2,y,t)$,
 where $\gamma=\sum_i \gamma_i$.

\item the  {\it JK residue formulae} \cite{Hori:2014tda} (see also \cite{Cordova:2014oxa,Benini:2013xpa}) is based on localization, and evaluates the $\chi$-index
$\Omega(\gamma,\zeta,y,y)$ as a suitable sum of residues of a certain rational or trigonometric function; when $\gamma$ is not primitive, the residue formula computes the value at $y=t$ of the rational invariant
\eqref{defbOm}.

\item the  {\it flow tree formula} \cite{Alexandrov:2018iao} is based on 
 the attractor flow tree conjecture, and expresses the total index in terms of attractor indices
 $\Omatt(\gamma_i,y,t)$ which are also independent of stability conditions, but may depend on both 
 $y$ and $t$; the attractor index is defined by  $\Omatt(\gamma,y,t)=\Omega(\gamma,\zeta_*,y,t)$ 
 where $\zeta_*$ is 
 a generic perturbation of the attractor point $\zeta_a=-\kappa_{ab} N_b$;  

\item the {\it attractor tree formula} \cite{BPMozgovoy} (based on ideas in \cite{Alexandrov:2019rth})
is (believed to be) equivalent
to the  {\it flow tree formula}, but it does not rely on perturbing the DSZ matrix $\gamma_{ij}$
in intermediate steps.


\item the {\it Quiver Yangian algorithm} \cite{BPinprogress}, based on ideas in \cite{Li:2020rij},  computes unrefined NCDT invariants for brane tilings.  

\end{itemize}



\medskip

The package file {\tt CoulombHiggs.m} and various example files 
can be obtained from the author's webpage,
\vskip 2mm

\centerline{\tt http://www.lpthe.jussieu.fr/$\sim$\,pioline/computing.html}

\subsection{Basic usage}

Assuming that the file {\tt CoulombHiggs.m} is present in the user's {\sc Mathematica} Application 
directory, the package is loaded by entering 

\mathematica{1.0}{ <<CoulombHiggs`}{CoulombHiggs 6.0 - A package for evaluating quiver invariants. }

If the file  {\tt CoulombHiggs.m} has not yet been copied in the user's {\sc Mathematica} Application 
directory but is in the same directory as the notebook, evaluate instead

\mathematica{1.0}{SetDirectory[NotebookDirectory[]]; <<CoulombHiggs`}{CoulombHiggs 6.0- A package for evaluating quiver invariants.}

\subsubsection{Coulomb branch formula}

The basic usage of {\tt \color{functioncolor} CoulombBranchFormula} is illustrated below: \footnote{Note the following changes in v2.0: the fugacity $y$ 
is no longer a parameter of \fun{CoulombBranchFormula} and \fun{QuiverBranchFormula},
and the former computes the Dolbeault polynomial in terms of $\OmS(\alpha_i,t)$, 
rather than expressing  the Poincar\'e polynomial in terms of $\OmS(\alpha_i)$.
Starting in v2.1, if $\sum_i N_i \zeta_i$  does not vanish, rather than issuing an error message,
a uniform translation is applied internally to the $\zeta_i$'s.  %bp
Other changes are highlighted by margin notes below. }


\mathematica{1.0}{Simplify[CoulombBranchFormula[4\{\{0, 1, -1\},\{-1, 0, 
   1\}, \{1, -1, 0\}\}, \{1/2, 1/6, -2/3\}, \{1, 1, 1\}]]  
     }
   {$ 2+ \frac{1}{y^2}+y^2 +  \text{OmS}(\{1,1,1\},y,t) $
}


%\mathematica{0.9}{Simplify[CoulombBranchFormulaNew[4\{\{0, 1, -1\},\{-1, 0, 
%   1\}, \{1, -1, 0\}\}, \{1/2, 1/6, -2/3\}, \{1, 1, 1\}]]
%%   /.  \{\text{OmS[gam\underline{~}, y\smallwedge n\underline{~}] -> OmS[gam, t\smallwedge
%%   n]},  \text{OmS[gam\underline{~}, y] -> OmS[gam, t]}\}
%  }
%   {$ 2+ \frac{1}{y^2}+y^2 +  \text{OmS}(\{1,1,1\}, t) $
%}

The first argument corresponds to the matrix of DSZ products $\alpha_{ij}$ (an antisymmetric matrix of integers), the second to the FI parameters $\zeta_i$ (a vector of rational numbers), the third to the dimension vector $N_i$ (a vector of integers). 
%The variables
% $y$ and $t$ are fugacities conjugate to the sum of the Dolbeault
%degrees $p+q$ (i.e. the angular
%momentum) and to the difference of the Dolbeault
%degrees $p-q$, respectively. The Poincar\'e-Laurent
%polynomial is obtained by setting $t=1$. For generic superpotential, the single-centered
%indices $\OmS(\gamma,y)\equiv \OmS(\gamma,y,1)$ are conjectured to be
%independent of $y$.  
Here,  the 
Dolbeault polynomial of the moduli space of a three-node Abelian cyclic quiver $C_{4,4,4}$ with $4$ arrows between each consecutive node is expressed in terms of the single-centered index
$\OmS(\gamma_1+\gamma_2+\gamma_3,y,t)$. 

\subsubsection{Higgs branch formula}

The arguments of {\tt \color{functioncolor} HiggsBranchFormula} are the same as for {\tt \color{functioncolor} CoulombBranchFormula}: 

\mathematica{1.0}{Simplify[HiggsBranchFormula[\{\{0, 3\},\{-3, 0\}\}, \{1/2,-1/2\}, \{2, 2\}]]
  }
   {$ -\frac{\left(y^2+1\right) \left(y^8+y^4+1\right)}{y^5} $
}
The above command computes the invariant $\Omega(\gamma,\zeta,t,y)$ for the Kronecker quiver 
$K_3(2,2)$ with 3 arrows,  dimension vector $\gamma=(2,2)$ and stability  parameters 
$\zeta=(1/2,-1/2)$. This is computing by expressing $\Omega(\gamma)$ in terms of the rational
invariant $\bOm(\gamma)$, then $\bOm(\gamma)$ in terms of the stack invariant, which is
then evaluated using Reineke's formula. 
Note that the result is a symmetric Laurent polynomial with integer coefficients, despite the fact that $\gamma$ is not primitive. 

\subsubsection{Jeffrey-Kirwan residue  formula}

\begin{center}
{\bf Beware: the routine \fun{JKIndex} appears to have become corrupted due to changes in v5. Please use \fun{JKIndexSplit} or revert to v4.} 
\end{center}

The third main routine {\tt \color{functioncolor} JKIndex} implements the Jeffrey-Kirwan residue formula. 
Its first argument \var{ChargeMatrix} is an extended charge matrix, where the rows encode the charges of the chiral
multiplets under $U(1)^{\sum N_i}$, along with the R-charges and the multiplicity. 
The second argument \var{Nvec} is the dimension vector $N_i$, and the last argument 
\var{Etavec} is the stability condition $\eta$, a vector of length $\sum_i N_i$. These  arguments 
can be generated by using \fun{JKInitialize}, which takes as arguments  the antisymmetric DSZ matrix $\alpha_{ij}$, symmetric R-matrix $r_{ij}$, stability
vector $\zeta_i$ and dimension vector $N_i$, and sets various global variables including  
\var{JKChargeMatrix} and \var{JKEta}.  For example,  the index of a two-node quiver with three arrows, dimension vector $N_i=(1,2)$, stability vector 
$\eta=(1,-2/5,-3/5)$ is obtained from 

\mathematica{1.0}{
JKInitialize[\{\{0, 3\}, \{-3, 0\}\}, \{\{0, 0\}, \{0, 0\}\}, \{1, 2\}, \{1, -1/2\}];
JKIndex[ JKChargeMatrix, \{1, 2\},JKEtavec]
}{$\{y^2+1+\frac{1}{y^2} \}$}   

\noindent 
The result produces a list of contributions from each contributing stable flag, which consists of a single flag in this case. The routine first determines the stable flags which give a non-zero contribution to the Euler number $\Omega(\gamma,\zeta,1,1)$, and then uses the same flags to compute the $\chi$-genus $\Omega(\gamma,\zeta,y,y)$, which is more time-consuming. The result for the Euler number can be accessed from the global variable \var{JKEuler}. Note that flavor fugacities
can be switched on by using  the routine \fun{FlavoredRMatrix} to construct  the matrix of R-charges (which was chosen to vanish in the previous example).


%The variable $\var{JKFrozenCartan}$ is a list of pairs $(i,s)$, which specifies that the list of Cartan variables $u_{i,s}$ (associated to the $i$-th gauge group $U(N_i)$, with $s=1\dots N_i)$ should be frozen to 0, rather than integrated over. For quiver quantum mechanics the overall $U(1)$ factor in $\prod_i U(N_i)$ decouples one variable, e.g. $u_{1,1}$, must be frozen to 0.

\medskip

A variant {\tt \color{functioncolor} JKIndexSplit} of the same routine is provided, which computes the same index by first splitting the vector multiplet determinants as a sum over (equivalence classes of) permutations, using Cauchy's determinant formula, and computes the Jeffrey-Kirwan residue of each term separately (the two procedures are of course identical for Abelian quivers). This simplifies both the enumeration of stable flags (as the number of singular hyperplanes due to vector multiplets is reduced from $N_i(N_i-1)$ to $\mathcal{O}(N_i)$) and the computation of the residues. Moreover, for quivers with loops this splitting appears to match the sum over decompositions $\gamma=\sum\alpha_i$ in the Coulomb branch formula \cite{Beaujard:2019pkn}. For example, applying this splitting procedure on the second node for the previous example gives

\mathematica{1.0}{
JKInitialize[\{\{0, 3\}, \{-3, 0\}\}, \{\{0, 0\}, \{0, 0\}\}, \{1, 2\}, \{1, -1/2\}];
JKIndexSplit[ JKChargeMatrix, \{1, 2\},JKEta,\{2\}];
}{$\{ \{ \frac{-y^8-y^4-1}{2 y^4} \} , \{ 
 \frac{\left(y^4+y^2+1\right)^2}{2 y^4}\} \}$}   

\noindent which sums up to the same result as before $y^2+1+1/y^2$. 
Each entry in the result corresponds to the contribution
of a given multi-partition of the dimension vector, the list of which  is stored (along with respective multiplicities) in the global variable ${\tt \color{varcolor} JKListAllPerms}$. Again, the intermediate 
results for the Euler number can be retrieved from the global variable \var{JKEuler}.

\medskip

For the evaluation of the residue, we note that it is often more efficient to use a rational representation of the integrand (using exponentiated Cartan variables) than a trigonometric representation. The former is used when $\var{\$QuiverTrig}$ is set to False. If this variable is set to a value different from True or False, then  the routine does not attempt to compute the full $\chi$-genus and returns the Euler number instead. 

\medskip

Finally, by setting $\var{\$QuiverTrig}$ to True and $ \var{\$QuiverMaxPower}>0$, the routine will attempt to compute the elliptic genus up to order $q^{\var{\$QuiverMaxPower}}$ using the residue prescription in \cite{Benini:2013xpa}. Note however that it will only include the same hyperplanes which contribute to the Euler number, and not hyperplanes which decouple as $\tau\to\I\infty$.



\subsubsection{Flow tree  formula}

The arguments for \fun{\tt FlowTreeFormula} are the same as for {\tt \color{functioncolor} CoulombBranchFormula}:

\mathematica{1.0}{Simplify[FlowTreeFormula[4\{\{0, 1, -1\},\{-1, 0, 
   1\}, \{1, -1, 0\}\}, \{1/2, 1/6, -2/3\}, \{1, 1, 1\}]]  
     }
   {$  \text{OmAtt}(\{1,1,1\},y) $
}

\noindent In this case, the sum over tree vanishes. Comparing with the result from the Coulomb branch formula above, one concludes that the attractor index  $\Omega_*(\gamma)=\OmS(\gamma)+y^2+2+1/y^2$, corresponding to the sum of the contributions of single centered and scaling solutions.

\subsubsection{Attractor tree  formula}

As of version 5.2, the package contains an implementation of a formula implicit in \cite{Alexandrov:2019rth}, which allows to express the index $\Omega(\gamma,\zeta,y,t)$ in terms of 
attractor indices  $\Omega_\star(\gamma,\zeta,y,t)$, without perturbing the DSZ matrix at any stage.
The syntax is identical to the flow tree formula, 

\mathematica{1.0}{Simplify[AttractorTreeFormula[4\{\{0, 1, -1\},\{-1, 0, 
   1\}, \{1, -1, 0\}\}, \{1/2, 1/6, -2/3\}, \{1, 1, 1\}]]  
     }
   {$  \text{OmAtt}(\{1,1,1\},y) $
}

\subsubsection{Quiver Yangian algorithm}

The algorithm relies on a matrix $\var{hMat}$ whose entry $(i,j)$ lists the heights $h_a$ of arrows
$a:i\to j$. These heights are linear combinations of three parameters $h_1,h_2,h_3$ such that, for all vertices $i\in Q_0$
\be
\label{vertexc}
\forall i: \quad 
 \sum_{a:i\to j} h(a) -  \sum_{a:j\to i}  h(a)= 0
\ee
and for all monomials $F\in Q_2$ in the superpotential $W=W_+-W_-$,
\be
\label{loopcr}
\forall F:\quad \sum_{a\in F} h'(a) = h_3
\ee
These heights, as well as the bipartite potential $W=W_+-W_-$,  are pre-computed for a number of common brane tilings, listed by 

\mathematica{1.0}{Simplify[ListKnownBraneTilings]  
     }
   {$\begin{array}{l} 1:C^3 \\
2:{\rm Conifold}\\
3:C^2\times C/2\\
4:C^2\times C/3\\
5:C^3/2\times 2\\
6:SPP\\
7:L131\\
8:P2=C^3/(1,1,1)\\
9:F0.1=P1\times P1\\
\dots
\end{array}$
}
For computing unrefined NCDT invariants for the conifold up to order $x^5$, you may use

\mathematica{1.0}{
\{Tiling, Fan, hMat, Wp, Wm, v1, v2\} = BraneTilingsData[[2]];
NCDTSeriesFromCrystal[hMat, \{1, 0\}, 5] }
   {
   $1 + x[1] + 2 y^3 x[1] x[2] + 4 y^5 x[1]^2 x[2] + 2 y^5 x[1]^3 x[2] + 
 y^4 x[1] x[2]^2 + 8 y^{10} x[1]^2 x[2]^2 + 14 y^{14} x[1]^3 x[2]^2 + 
 4 y^{13} x[1]^2 x[2]^3$
}
and set $y=-1$ in the final result. Setting $y=1$ instead gives the number of molten crystals
at each order. 


\subsection{Online documentation}

The package contains many more routines, documented below, which can be used independently. Basic inline documentation can be obtained by typing e.g. 

\mathematica{1.0}{?CoulombBranchFormula}
   {CoulombBranchFormula[Mat\_,Cvec\_,Nvec\_] expresses the Dolbeault polynomial of a quiver with dimension vector gam in terms of the single center degeneracies OmS[alpha\_i,t] 
   using the Coulomb branch formula, computing all CoulombH factors recursively using the minimal modification hypothesis. Also provides list of CoulombH factors if \$QuiverDisplayCoulombH is set to True }
   
\subsection{History}   
   
The first version of this package was released together with the preprint \cite{Manschot:2013sya} where a general algorithm for computing the index of the quantum mechanics of multi-centered BPS black holes (the Coulomb index) was outlined. The version 2.0, released along with the preprint \cite{Manschot:2012rx}, allowed to compute the Dolbeault-Laurent polynomial, relax assumptions on single-centered indices for basis vectors, study the effect of generalized mutations, and more. Version 2.1, released along with the review \cite{Manschot:2014fua}, was optimized to speed up the evaluation of Coulomb indices.  Version 3.0 introduced 
an early version of the Jeffrey-Kirwan residue formula. Version 4.0, released along with \cite{Alexandrov:2018iao}, introduced  the flow tree formula. Version 5.0, released along with \cite{Beaujard:2019pkn},
introduced  more robust implementation of the Jeffrey-Kirwan residue formula.
Version 6.0, released along with \cite{BPMozgovoy}, introduces the attractor tree formula and the Quiver Yangian algorithm, along with many routines for dealing with brane tilings. 
Version 6.2, released along with \cite{Beaujard:2021fsk}, includes routines for computing the index of Abelian quivers by solving deformed
Denef equations. 



\subsection{Usage in literature}
The following papers by other authors have acknowledged using this package for part of their computations (non exhaustive list): 
\cite{Cordova:2013bza,Gaddam:2016xum,Messamah:2020ldn,Duan:2020qjy,Banerjee:2020moh,Longhi:2021qvz}.



\section{Variables and Symbols}

\subsection{Symbols}
 
\defvar{y}{fugacity conjugate to the sum of Dolbeault degrees $p+q$ (i.e. angular momentum);}

\newnotea \defvar{z}{chemical potential, $y=e^{i\pi z}$;}



\defvar{t}{fugacity conjugate to the difference of Dolbeault degrees $p-q$;}

\defvar{q}{modular parameter in the elliptic genus, $q=e^{2\pi i \tau}$;}

\defvar{tau}{elliptic modulus, $q=e^{2\I\pi\tau}$, for elliptic genus computations;}



\defn{Om}{\vardef{charge vector},\newdefy}{denotes the refined index  
$\Omega(\gamma,y)$;}

\defn{Omb}{\vardef{charge vector},\newdefy }{denotes the rational refined index
$\bar\Omega(\gamma,y)$;}


\defn{OmS}{\vardef{charge vector},\newdefy,\vardef{t} }{denotes the single-centered index 
$\OmS(\gamma,y,t)$. } 

\defn{OmS}{\vardef{charge vector},\newdefy}{denotes 
$\OmS(\gamma,y)\equiv \OmS(\gamma,y,t=1)$.}

\defn{OmS}{\vardef{charge vector}}{denotes 
$\OmS(\gamma,y)$, under the assumption that it is independent of $y$ (which is
conjectured to be the case for  generic superpotential)}

\defn{OmAtt}{\vardef{gam},\newdefy}{denotes the attractor index with charge \var{gam}}

\defn{OmAttb}{\vardef{gam},\newdefy}{denotes the rational attractor index with charge\var{ gam}}


\defn{OmT}{\vardef{charge vector},\newdefy }{denotes the (unevaluated)  
function $\Omega_{\rm tot}(\gamma,y)$;}

\defn{Coulombg}{\vardef{list of charge vectors},\newdefy }{: denotes the (unevaluated) Coulomb index $\gref(\{\alpha_i\},\{c_i\},y)$, leaving the FI parameters unspecified;} 

\defn{HiggsG}{\vardef{charge vector},\newdefy }{denotes the (unevaluated)  
stack invariant $\gR(\gamma,y)$;}



\defn{CoulombH}{\vardef{list of charge vectors},\vardef{multiplicity vector},\newdefy }{denotes the (unevaluated) factor $H(\{\alpha_i\},\{n_i\},y)$ appearing in the formula  for 
$\Omega_{\rm tot}(\sum n_i\alpha_i,y)$  in terms of 
$\OmS(\alpha_i,y)$.}

\defn{QFact}{\vardef{n},\newdefy }{represents the (non-evaluated) $q$-deformed factorial $[n,y]!$}




\defvar{u[i,s]}{$s$-th Cartan variable for the $i$-th gauge group when the trigonometric representation is used,
exponentiated version $e^{2\pi i u_{i,s}}$ of the same when a rational representation is used.}

\defvar{ut[i,s]}{Cartan variables in rotated basis adapted to a singularity, so that the flag is $\tilde u_{1,1}=\dots = u_{K,N_K}=0$ in trigonometric representation, or $\tilde u_{1,1}=\dots = u_{K,N_K}=1$ in rational representation.}

\defvar{th[\vardef{i}]}{Chemical potential for flavor symmetry, used in \fun{FlavoredRMatrix}} 

\defvar{Theta[\vardef{z}]}{Jacobi Theta series $\theta_1(z,\tau)=-\I q^{1/8} (e^{\I \pi z}-e^{-\I \pi z)}) 
\prod_{k\geq 1} (1-q^k) (1-e^{2\pi \I z} q^k)(1-e^{-2\pi \I z} q^k) $}

\defvar{Eta}{Dedekind Eta series $\eta(\tau)=q^{1/24} \prod_{k\geq 1} (1-q^k)$}

\defvar{h1,h2,h3}{Parameters for the heights $h(a)$ used by the Quiver Yangian algorithm}


\subsection{Global variables}


\defvar{JKListuAll}{Flat list of all Cartan variables $u[i,s]$, $i=1\dots K$, $s=1,\dots N_i$}

\defvar{JKListuDisplay}{Same as \var{JKListuAll}, only used by \fun{FlagToHyperplane} for display}

\defvar{JKListu}{Flat list of unfrozen Cartan variables $u[i,s]$}

\defvar{JKListut}{Flat list of unfrozen rotated Cartan variables $ut[i,s]$}

\defvar{JKFrozenCartan}{List of pairs $\{i,s\}$ which specifies the list of Cartan variables $u_{i,s}$ which should be frozen to 0 (or 1 in rational representation), rather than integrated over. }

\defvar{JKFrozenMask}{Vector of booleans indicating non-frozen entries in \var{JKListuAll}}


\defvar{JKFrozenRuleEuler}{Rule for replacing the frozen $u[i,s]$ by 0}

\defvar{JKFrozenRuleRat}{Rule for replacing the frozen $u[i,s]$ by 1}



\defvar{JKEuler}{List of contributions of all stable flags to the Euler number, as computed by \fun{JKIndex} or \fun{JKIndexSplit}}

\defvar{JKChiGenus}{List of contributions of all stable flags to the chi-genus, as computed by \fun{JKIndex} or \fun{JKIndexSplit}}

\defvar{JKListAllSings}{List of singularities, as computed by \fun{JKIndex} or \fun{JKIndexSplit}}

\defvar{JKListAllStableFlags}{List of all stable flags, as computed by \fun{JKIndex} or \fun{JKIndexSplit}}

\defvar{JKRelevantStableFlags}{List of stable flags contributing to the Euler number, as computed by \fun{JKIndex} or \fun{JKIndexSplit}}

\defvar{JKListAllPerms}{List of multi-partitions, as computed by \fun{JKIndexSplit}}

\defvar{JKVertexCoordinates}{Coordinates of vertices for \fun{DisplayFlagTree}, set by \fun{JKInitialize}}

\defvar{JKVertexLabels}{Labels of vertices for \fun{DisplayFlagTree}, set by \fun{JKInitialize}}

\defvar{BraneTilingsData}{List of \{Name, Fan, hMat, Wp, Wm, v1,v2 \} for known brane tilings,
where \var{Fan} is the toric fan (see \fun{PlotToricFan}), \var{hMat} the height matrix (see \fun{NCDTSeriesFromCrystal}), $W=\var{Wp}-\var{Wm}$ the superpotential (see \fun{ListPerfectMatchings}) and $\var{v1},\var{v2}$ the two basis vectors used by \fun{PlotTiling} to display the tiling.}


\subsection{Environment variables}


\defvar{{\tt \$QuiverPerturb1}}{Sets the size of the perturbation $\epsilon_1=1/\var{\$QuiverPerturb}$ of the DSZ products, set to 1000 by default.}

\defvar{{\tt \$QuiverPerturb2}}{Sets the size of the perturbation $\epsilon_2=1/\var{\$DSZPerturb}$ of the DSZ products, set to $10^{10}$ by default.}


\defvar{{\tt \$QuiverNoLoop}}{If set to True, the quiver will be assumed to have no oriented loop, hence all $H$ factors and all $\OmS(\alpha)$ will be set to zero (unless $\alpha$ is a basis vector). Set to False by default.}

\defvar{{\tt \$QuiverTestLoop}}{If set to True, all $H$ factors and $\OmS(\alpha)$ corresponding to subquivers without loops will be set to zero (unless $\alpha$ is a basis vector).
Set to True by default.
Determining whether a subquiver has loops is time-consuming, so for large quivers it may be advisable to disable this feature. Note that 
\var{{\tt \$QuiverNoLoop}} takes precedence over this variable.}

\defvar{{\tt \$QuiverMultiplier}}{Set to 1 by default. If $m=\var{\$QuiverMultiplier}$ is a positive scalar  (possibly a formal variable), then all entries of the DSZ matrix $\var{Mat}$ 
used in evaluations of \var{\tt Coulombg}, \var{\tt Treeg}, or \var{\tt HiggsG}
are effectively multiplied 
by $m$. If $m$ is a matrix, then entries $\var{Mat}[[i,j]]$ are multiplied by $m_{ij}$.}

\defvar{{\tt \$QuiverMultiplierAssumption}}{Specifies assumptions about formal variables used in 
\var{\$QuiverMultiplier}, for example $m\in {\rm Integers}$}

\defvar{{\tt \$QuiverVerbose}}{If set to False, all consistency tests on data and corresponding error messages will be skipped. Set to True by default.}

\defvar{{\tt \$QuiverDisplayCoulombH}}{If set to True, the routine 
\fun{\tt CoulombBranchFormula} will return a list   $\{ \var{Q}, \var{R} \}$ where
 $\var{Q}$  is the Poincar\'e-Laurent   polynomial and \var{R} is a  list of replacement rules for the \var{CoulombH} factors. Set to False by default.}

\defvar{{\tt \$QuiverPrecision}}{Sets the numerical precision with which all consistency tests
are carried out. This is set to 0 by default since all data are assumed to be rational numbers. This can be set to a small real number when using real data, however the user is warned that rounding errors
tend to grow quickly.}



\defvar{{\tt \$QuiverRecursion}}{If set to 1 (default value), then the new recursion relations 
from \cite[v2]{Manschot:2013sya} are used for computing
\fun{\tt CoulombF};  if set to 0  the recursion relation
from \cite[v1]{Manschot:2013sya}  is used instead. } 

\defvar{{\tt \$QuiverOmSbasis}}{Set to 1 by default. If set to 0,  the routines 
\fun{\tt SimplifyOmSbasis} and \fun{\tt SimplifyOmSbasismult} are deactivated, so that 
 the assumption that basis 
vectors carry $\OmS(\ell\gamma_i)=\delta_{\ell,1}$ is relaxed.}  

\defvar{{\tt \$QuiverCoulombOpt}}{Set to 1 by default. If set to 0,  the routines
\fun{\tt CoulombF}, \fun{\tt CoulombG}, \fun{\tt CoulombIndex} will use the non-optimized
code provided in version 2.0, otherwise they use the optimized code provided in version 2.1.
Before v5.1, this was called \var{ \$QuiverOpt} !}  

\defvar{{\tt \$QuiverFlowTreeOpt}}{Set to 3 by default. If set to 0, the original
formulation in  \cite[(2.57)]{Alexandrov:2018iao} is used.
If set to 1 or 2,  the first or 
second alternative recursion in  \cite[(2.64)]{Alexandrov:2018iao}
will be used to evaluate the tree index. If set to 3, an optimized version of 
the original flow tree formula in \cite{Alexandrov:2018iao} is used.}  

\defvar{{\tt \$QuiverFlowTreeMethod}}{Set to 0 by default. If set to 1, the wall-crossing in \fun{NonAbelianTreeFlowFormula} will be computed the Coulomb branch formula, otherwise
it is computed using Reineke's formula for Abelian stack invariants. }   

\defvar{{\tt \$QuiverNoVM}}{Set to False by default. If set to True, singular hyperplanes from 
vector multiplet determinant will be ignored in \fun{JKIndex} and \fun{JKIndexSplit}.}

\defvar{{\tt \$QuiverTrig}}{Set to True by default. If set to False, exponentiated variables will be used
for the residue computation in \fun{JKIndex} and \fun{JKIndexSplit}.}

\defvar{\$QuiverMaxPower}{Maximal power in the $q$-expansion of the elliptic genus. Set to 0 by default.}

\defvar{\$QuiverMutationMult}{Equal to 1 by default. Set to $M$, defined in Eq. (1.8) of
  \cite{Manschot:2013dua} when dealing with generalized quivers.}  

\defvar{\$QuiverVertexLabels}{specifies the vertex labels to be used by \fun{PlotQuiver} and
\fun{PlotTiling}.}  


%\end{itemize}

\section{Higgs branch formula}

\defn{HiggsBranchFormula}{\vardef{Mat},\vardef{Cvec},\vardef{Nvec} }
	                                   {standalone routine which computes the Poincar\'e-Laurent
                   polynomial  of a quiver with DSZ products $\alpha_{ij}=\var{Mat}[[i,j]]$ (possibly              rescaled by \var{{\tt \$QuiverMultiplier}}), dimension vector $N_i=\var{Nvec}[[i]]$, 
                   FI parameters $\zeta_i=\var{Cvec}[[i]]$, using Reineke's formula. 
                   It is assumed, but not checked, that the quiver has no oriented 
                   loop;}


\defn{StackInvariant}{\vardef{Mat},\vardef{Cvec},\vardef{Nvec},\newdefy }{gives 
                 the stack 
                  invariant $G_{\rm Higgs}(\gamma,\zeta,y)$
                  of a quiver with DSZ matrix $\alpha_{ij}=\var{Mat}[[i,j]]$, possibly rescaled 
                  by an overall factor of 
                   \var{{\tt \$QuiverMultiplier}}, 
                  FI parameters $\zeta_i=\var{Cvec}[[i]]$,  dimension vector $N_i=\var{Nvec}[[i]]$, 		using Reineke's formula; the answer is written in terms of unevaluated
		$q$-deformed factorials \var{QFact[n,y]};}
		
		\defn{AbelianStackInvariant}{\vardef{Mat},\vardef{Cvec},\newdefy }{gives 
                 the Abelian stack 
                  invariant 
                  of a quiver with DSZ matrix $\alpha_{ij}=\var{Mat}[[i,j]]$, possibly rescaled 
                  by an overall factor of 
                   \var{{\tt \$QuiverMultiplier}}, 
                  FI parameters $\zeta_i=\var{Cvec}[[i]]$, 		
                  using Reineke's formula; coincides with \fun{\tt StackInvariant} 
                  with \var{Nvec}$=\{1,\dots 1\}$ except that tests of marginal or threshold stability
                  are performed (unless   \var{\tt \$QuiverVerbose} is set to False);
                  }

\defn{OmToOmb}{\vardef{f}}{expresses any $\Omega(\gamma,y)$ in $f$
 in terms of $\bar\Omega(\gamma,y)$'s;}

\defn{OmbToOm}{\vardef{f}}{expresses  any $\bar\Omega(\gamma,y)$ in $f$
 in terms of $\Omega(\gamma,y)$'s;}

\defn{OmbToHiggsG}{\vardef{Cvec},\vardef{f} }{expresses  any $\bar\Omega(\gamma,y)$ in $\var{f}$
in terms of the (unevaluated) stack invariants $\gR(\gamma,y)$  using \cite[(4.1)]{Manschot:2013sya};
if the first argument is omitted, a generic stability condition is assumed.}

\defn{HiggsGToOmb}{\vardef{Nvec},\newdefy }{expresses  any
$\gR(\gamma,y)$ in $\var{f}$ in terms of the rational refined indices $\bar\Omega(\gamma,y)$ using \cite[(4.5)]{Manschot:2013sya}; if the first argument is omitted, a generic stability condition is assumed.}

\defn{EvalReinekeIndex}{\vardef{Mat},\vardef{Cvec},\vardef{f} }{evaluates
any $\var{Coulombg[Li,y]}$ appearing in $\var{f}$ as \fun{ReinekeIndex}[\var{Mat2},\var{Cvec2},\var{y}], where $\var{Mat2},\var{PMat2},\var{Cvec2}$ are computed from the list of vectors $\var{Li}$ and the quiver data $\var{Mat},\var{Cvec}$. }

\defn{ReinekeIndex}{\vardef{Mat},\vardef{Cvec},\vardef{y}}{computes the stack invariant 
after perturbing the stability parameters.}



\section{Coulomb branch formula}

 \defn{CoulombBranchFormula}{\vardef{Mat},\vardef{Cvec},\vardef{Nvec}}
	                                   {computes  the Dolbeault %Poincar\'e-Laurent
                   polynomial  of a quiver with DSZ products $\alpha_{ij}=\var{Mat}[[i,j]]$,
                   dimension vector $N_i=\var{Nvec}[[i]]$, 
                   FI parameters $\zeta_i=\var{Cvec}[[i]]$,
                   in terms of single-centered invariants $\OmS$.
                  This standalone routine first constructs the Poincar\'e-Laurent 
                  polynomial,
                   evaluates the Coulomb indices $\gref$, 
                   determines the $H$ factors recursively using the minimal modification hypothesis
                   and finally replaces $y$ by $t$ in the argument of $\OmS$ to construct
                   the Dolbeault polynomial. 
If \var{{\tt \$QuiverDisplayCoulombH}} is 
                   set to True, the routine  returns a list $\{ \var{Q}, \var{R} \}$,
                                    where $\var{Q}$ is the Poincar\'e polynomial and \var{R} is a  list of replacement rules for the \var{CoulombH} factors.
                                                       For quivers without loops, the process can be sped up greatly by setting \var{\tt \$QuiverNoLoop} to True.
                   For complicated quivers
                   it is advisable to implement the Coulomb branch formula step by step, using the 
                   more elementary routines described below. 
                   }

\subsection{Generating the sum over all splittings}


\defn{QuiverPoincarePolynomial}{\vardef{Nvec},\newdefy }{constructs the Poincar\'e-Laurent
                   polynomial $\Omega(\gamma,\zeta,y,t)$ as a sum over all partitions of the dimension vector $\var{Nvec}$. Coincides with
                   \fun{QuiverPoincarePolynomialRat}                   for primitive dimension vector;
                 }


\defn{QuiverPoincarePolynomialRat}{\vardef{Nvec},\newdefy }{constructs the rational Poincar\'e-Laurent
                   polynomial $\bOm(\gamma,\zeta,y,t)$  as a sum over all partitions of the dimension vector $\var{Nvec}$ ;}
         
\defn{QuiverPoincarePolynomialExpand}{\vardef{Mat},\vardef{PMat},\vardef{Cvec},
\vardef{Nvec}, \vardef{Q}}{
                  evaluates the Coulomb 
                  indices $\gref$ and   total 
                   single-centered indices $\Omega_{\rm tot}(\alpha_i,y)$   appearing in the 
                  Poincar\'e-Laurent polynomial \var{Q} of a quiver with DSZ products
                  $\alpha_{ij}=\var{Mat}[[i,j]]$, perturbed to 
                   $\var{PMat}[[i,j]]$, 
                   dimension vector $N_i=\var{Nvec}[[i]]$, 
                 FI parameters $\zeta_i=\var{Cvec}[[i]]$;}

\defn{ListAllPartitions}{\vardef{gam}}{returns the list of unordered 
                   partitions $\{\alpha_i\}$ of the positive integer vector $\gamma$ as a sum of positive, non-zero integer vectors $\alpha_i$; 
                   }
                   
                   \defn{ListAllPartitionsMult}{\vardef{gam}}{returns the list of unordered 
                   partitions $\{\alpha_i,m_i\}$ of the positive integer vector $\gamma$ as a sum of positive, non-zero integer vectors $\alpha_i$ with multiplicity $m_i$; 
                   }

\defn{ListSubQuivers}{\vardef{Nvec}}{gives a list of all dimension vectors less or equal to \var{Nvec};}



 \defn{SymmetryFactor}{\vardef{Li}}{gives the symmetry factor $1/  |{\rm Aut}(\{\alpha_1, \alpha_2,\cdots, \alpha_n\}|$ for the list of charge vectors \var{Li};}



           

\defn{OmTRat}{\vardef{Nvec},\newdefy }{ gives the rational total invariant 
$\bar\Omega_{\rm tot}(\gamma,y)$ in terms of $\Omega_{\rm tot}(\gamma,y)$.
Coincides with the latter if $\gamma$ is primitive.}

\defn{OmTToOmS}{\vardef{f}}{expands out any $\Omega_{\rm tot}(\gamma,y)$ in $f$
 into $H$ factors and $\OmS$'s;}


\subsection{Computing the Coulomb index}


\defn{SubDSZ}{\vardef{Mat},\vardef{PMat},\vardef{Cvec},\vardef{Li}}{gives the
                    DSZ matrix, perturbed DSZ matrix and FI parameters of the Abelian subquiver made of the charge vectors in list \var{Li};}

\defn{CoulombF}{\vardef{Mat},\vardef{Cvec}}{returns the index of collinear solutions 
$F(\{\ta_1,\cdots \ta_n\}, \{\cc_1,\cdots \cc_n\})$ with 
                   DSZ products $\ta_{ij}=\var{Mat}[[i,j]]$, FI terms $\cc_i=\var{Cvec}[[i]]$ 
                   and trivial ordering.}

\defn{CoulombG}{\vardef{Mat}}{returns the index of scaling collinear solutions 
$G(\{\ha_1,\cdots \ha_n\})$ 
with  DSZ products $\ha_{ij}=\var{Mat}[[i,j]]$ and trivial ordering. The total angular momentum 
                   $\sum_{i<j} Mat[[i,j]]$ must vanish;}

\defn{CoulombIndex}{\vardef{Mat},\vardef{PMat},\vardef{Cvec},\newdefy }{evaluates the Coulomb index $\gref(\{\alpha_1,\cdots $ $\alpha_n\};$ $\{\dx_1,\cdots \dx_n\},y)$ 
                   with DSZ products $\alpha_{ij}=\var{Mat}[[i,j]]$, perturbed to \var{PMat}[[i,j]] so as to lift 
                   accidental degeneracies, possibly rescaled by an overall factor of 
                   \var{{\tt \$QuiverMultiplier}}, 
                   FI terms $\dx_i=\var{Cvec}[[i]]$, angular momentum fugacity \var{y};
                   }


\defn{CoulombFNum}{\vardef{Mat}}{computes numerically the index $F(\{\ta_1,\dots \ta_n\},\{\cc_1,\dots \cc_n\})$  with DSZ matrix $\ta_{ij}=\var{Mat}[[i,j]]$ and FI parameters $\cc_i=\var{Cvec}[[i]]$. For testing purposes only, works for up to 5 centers.}

\defn{CoulombGNum}{\vardef{Mat}}{computes numerically the scaling index $G(\ha_1,\dots \ha_n)$  with DSZ matrix $\ha_{ij}=\var{Mat}[[i,j]]$. For testing purposes only, works for up to 6 centers.}
                   

\defn{CoulombIndexNum}{\vardef{Mat},\vardef{PMat},\vardef{Cvec},\newdefy }{returns the Coulomb index $\gref(\{\alpha_1,\cdots $ $\alpha_n\};$ $\{\dx_1,\cdots \dx_n\},y)$ 
                   with DSZ products $\alpha_{ij}=\var{Mat}[[i,j]]$,  possibly rescaled by an overall factor of 
                   \var{{\tt \$QuiverMultiplier}},  
                   FI terms $\dx_i=\var{Cvec}[[i]]$, angular momentum fugacity \var{y}, by searching
                   collinear solutions numerically;    For testing purposes only, works for up to 5 centers. The output is a list of contributions from each collinear solution.              }


\defn{EvalCoulombIndex}{\vardef{Mat},\vardef{PMat},\vardef{Cvec},\vardef{f} }{evaluates
any $\var{Coulombg[Li,y]}$ appearing in $\var{f}$ as $\var{CoulombIndex[\var{Mat2},\var{PMat2},\var{Cvec2},y]}$, where $\var{Mat2},\var{PMat2},\var{Cvec2}$ are computed from the list of vectors $\var{Li}$ and the quiver data $\var{Mat},\var{PMat},\var{Cvec}$. }

\defn{EvalCoulombIndexAtt}{\vardef{Mat},\vardef{PMat},\vardef{f} }{evaluates
any $\var{Coulombg[Li,y]}$ appearing in $\var{f}$ as $\var{CoulombIndex[\var{Mat2},\var{PMat2},\var{Cvec2},y]}$, where $\var{Mat2},\var{PMat2}$ are computed from the list of vectors $\var{Li}$ and the quiver data $\var{Mat},\var{PMat}$ and $\var{Cvec2}$ are the respective attractor moduli.}
  


\subsection{Contributions from scaling solutions}
                   
 \defn{CoulombBranchFormulaFromH}{\vardef{Mat},\vardef{Cvec},\vardef{Nvec},\vardef{R} }
	                                   {returns the Dolbeault
                   polynomial  of a quiver with DSZ products $\alpha_{ij}=\var{Mat}[[i,j]]$,  
                   dimension vector $N_i=\var{Nvec}[[i]]$, 
FI parameters $\zeta_i=\var{Cvec}[[i]]$, using the rule 
           \var{R} to replace all \var{CoulombH} factors.}
                   



\defn{CoulombHSubQuivers}{\vardef{Mat},\vardef{PMat},\vardef{Nvec},\newdefy }{computes recursively all \var{CoulombH} factors for DSZ matrix \var{Mat}, perturbed to \var{PMat},
and any dimension vector strictly less than \var{Nvec}; relies on the next two routines:}

                  
                   \defn{ListCoulombH}{\vardef{Nvec},\vardef{Q}}{ returns
                   returns
                   a pair $\{\var{ListH},\var{ListC}\}$ where \var{ListH} is a list of \var{CoulombH}
                    factors possibly
                   appearing in the Poincar\'e-Laurent polynomial \var{Q }of a quiver with dimension vector 
                   \var{Nvec}, and \var{ListC} is the list of coefficients which multiply the monomials in 
                   $\OmS(\alpha_i,y)$ canonically associated to the $H$ factors in \var{Q}.}

         
\defn{SolveCoulombH}{\vardef{ListH},\vardef{ListC},
\vardef{R}}{ returns
                   a list of replacement rules for the \var{CoulombH} factors 
                   listed in \var{ListH}, by applying the minimal modification hypothesis
                   to the coefficients listed in \var{ListC}. The last argument  is 
                   a replacement rule for \var{CoulombH} factors associated to subquivers.}
                   

\defn{MinimalModif}{\vardef{f}}{returns the symmetric Laurent polynomial which coincides 
                   with the Laurent expansion expansion of the symmetric rational function $f$ at $y=0$, up to strictly positive powers of $y$. Here symmetric means invariant under $y\to 1/y$. In practice,
\fun{\tt  MinimalModif}[\var{f}] evaluates the contour integral in \cite{Manschot:2012rx}, Eq 2.9
\be
\label{uint}
\oint \frac{{\rm d} u}{2\pi {\rm i}} \frac{(1/u-u) \, f(u)}{(1-u y)(1-u/y)}
\ee 
by deforming the contour around 0 into a sum of counters over all poles of $f(u)$ and zeros
of $(1-uy)(1-u/y)$. This trick allows to compute \eqref{uint} even if the order of the pole of $f(y)$
at $y=0$ is unknown, which happens if  \var{{\tt \$QuiverMultiplier}} is a formal variable.
                   }

\defn{MinimalModifFast}{\vardef{f}}{returns the symmetric Laurent polynomial which coincides 
                   with the Laurent expansion expansion of the symmetric rational function $f$ at $y=0$, up to strictly positive powers of $y$. This uses the Mathematica function \fun{Residue}, assuming that the order of the pole at $y=0$ is manifest. 
                   }


                   \defn{EvalCoulombH3}{\vardef{Mat},\vardef{f}}{ evaluates any 3-center $H$ factor with multiplicity vector $\{1,1,1\}$ 
               appearing   in $f$. No longer in use.}



\subsection{Simplifying the result}

\defn{SimplifyOmSbasis}{\vardef{f}}{replaces  $\OmS(\gamma,y)\to 1$ when $\gamma$ is a basis vector, unless  \var{{\tt \$QuiverOmSbasis}} is set to 0; 
}  

\defn{SimplifyOmSbasismult}{\vardef{f}}{replaces  $\OmS(\gamma,y)\to 0$ when $\gamma$   is a non-trivial multiple of a basis vector, unless  \var{{\tt \$QuiverOmSbasis}} is set to 0;} 



\defn{CoulombHNoLoopToZero}{\vardef{Mat},\vardef{f}}{sets to zero any $H$
                  factor in \var{f} corresponding to subquivers without loop, assuming DSZ products
                  $\alpha_{ij}=\var{Mat}[[i,j]]$
                  ; active only on 2-node subquivers if \var{{\tt \$QuiverTestLoop}} is set to False}


\defn{OmTNoLoopToZero}{\vardef{Mat},\vardef{f}}{sets to zero any $\Omega_{\rm tot}$
                  factor in \var{f} corresponding to subquivers without loop, assuming DSZ products
                  $\alpha_{ij}=\var{Mat}[[i,j]]$
                  ; active only on 2-node subquivers if \var{{\tt \$QuiverTestLoop}} is set to False
                  }

\defn{OmSNoLoopToZero}{\vardef{Mat},\vardef{f}}{sets to zero any $\OmS$  
                  factor in \var{f} corresponding to subquivers without loop, assuming DSZ products
                  $\alpha_{ij}=\var{Mat}[[i,j]]$
                  ; active only on 2-node subquivers if \var{{\tt \$QuiverTestLoop}} is set to False
                  }


\defn{DropFugacity}{\vardef{f}}{replaces $\OmS(\gamma,y^m,t^m)$ by $\OmS(\gamma,t^m)$ everywhere in $f$}  
                
\defn{SwapFugacity}{\vardef{f}}{replaces $\OmS(\gamma,y^m)$ with $\OmS(\gamma,y^m,t^m)$ everywhere in $f$} 

                   




\section{Mutations}  

The following routines and environment variables were introduced in  {\tt CoulombHiggs.m} v1.1,
to allow investigation of mutations of generalized quivers \cite{Manschot:2013dua}:

\defn{Mutate}{\vardef{Mat},\vardef{k}}{
Computes the  DSZ matrix of the quiver obtained
by applying a right-mutation with respect to the node $k$. If \var{k} is a list $\{k_i\}$,  then the
right mutations $k_i$ are applied successively, starting from the last entry in \var{k}. }

\defn{MutateRight}{\vardef{Mat},\vardef{Cvec},\vardef{Nvec},\vardef{k}}{
Computes the  DSZ matrix, FI parameters and dimension vector of the quiver obtained
by applying a right-mutation with respect to the node $k$. If \var{k} is a list $\{k_i\}$,  then the
right mutations $k_i$ are applied successively, starting from the last entry in \var{k}.  No
consistency check on the FI parameters is performed.}

\defn{MutateLeft}{\vardef{Mat},\vardef{Cvec},\vardef{Nvec},\vardef{k}}{
Computes the  DSZ matrix, FI parameters and dimension vector of the quiver obtained
by applying a left-mutation with respect to the node $k$. If \var{k} is a list $\{k_i\}$,  then the
right mutations $k_i$ are applied successively, starting from the last entry in \var{k}. No
consistency check on the FI parameters is performed.} 

\defn{OmStoOmS2}{\vardef{f}}{replaces $\var{\tt OmS[gam,y,t]}$ by $\var{\tt OmS2[gam,y,t]}$
anywhere in $\var{f}$. This is useful for distinguishing the single-centered invariants of the mutated
quiver from those of the original one.}

\defn{MutateRightOmS}{\vardef{Mat},\vardef{k},\vardef{f}}{expresses the single-centered
invariants $\var{\tt OmS[gam,y,t]}$ of the original quiver with DSZ matrix \var{Mat} in terms of the single-centered
invariants $\var{\tt OmS2[gam,y,t]}$ of the quiver obtained by right-mutation with respect to node $k$,
using Eq. 1.13 in \cite{Manschot:2013dua}.}

\defn{MutateLeftOmS}{\vardef{Mat},\vardef{k},\vardef{f}}{expresses the single-centered
invariants $\var{\tt OmS[gam,y,t]}$ of the original quiver with DSZ matrix \var{Mat} in terms of the single-centered
invariants $\var{\tt OmS2[gam,y,t]}$ of the quiver obtained by left-mutation with respect to node $k$,
using Eq. 1.13 in \cite{Manschot:2013dua}.}

\defn{MutateRightOmS2}{\vardef{Mat},\vardef{k},\vardef{f}}{expresses the single-centered
invariants $\var{\tt OmS2[gam,y,t]}$ a quiver with DSZ matrix \var{Mat} in terms of the single-centered
invariants $\var{\tt OmS[gam,y,t]}$ of the quiver obtained by right-mutation with respect to node $k$.
Identical to \fun{\tt MutateRightOmS}, except for swapping $\var{\tt OmS[gam,y,t]}$ and $\var{\tt OmS2[gam,y,t]}$.}

\defn{MutateLefttOmS2}{\vardef{Mat},\vardef{k},\vardef{f}}{expresses the single-centered
invariants $\var{\tt OmS2[gam,y,t]}$ a quiver with DSZ matrix \var{Mat} in terms of the single-centered
invariants $\var{\tt OmS[gam,y,t]}$ of the quiver obtained by right-mutation with respect to node $k$.
Identical to \fun{\tt MutateLeftOmS}, except for swapping $\var{\tt OmS[gam,y,t]}$ and $\var{\tt OmS2[gam,y,t]}$.}

\defn{DropOmSNeg}{\vardef{f}}{equates to 0 any $\OmS(\gamma,y,t)$ where the dimension
vector associated to $\gamma$ has negative components.}

\defn{CompareDSZMatrices}{\vardef{Mat1},\vardef{Mat2}}{gives a list of permutations $P$ such that $\var{Mat1}=\var{Mat2}[[P,P]]$, or an empty list if no such permutation exists; For $\var{Mat1}=\var{Mat2}$, gives the list of automorphisms of the antisymmetric matrix $\var{Mat1}$. 
}


\section{Jeffrey-Kirwan residue formula}

\begin{center}
{\bf Beware: the routine \fun{JKIndex} appears to have become corrupted due to changes in v5. Please use \fun{JKIndexSplit} or revert to v4.} 
\end{center}

\newnotea

\defn{JKInitialize}{\vardef{Mat},\vardef{RMat},\vardef{Cvec},\vardef{Nvec}}{initializes the internal variables \var{JKFrozenMask}, \var{JKFrozenRuleEuler}, \var{JKFrozenRuleRat}, \var{JKListu},   \var{JKListuAll},  \var{JKListuDisplay},  \var{JKListut}, \var{Etavec}, \fun{JKVertexCoordinates}, \fun{JKVertexLabels}. To be run before \fun{JKIndex} or \fun{JKIndexSplit}.}


\defn{JKIndex}{\vardef{ChargeMatrix},\vardef{Nvec},\vardef{Etavec}}{standalone routine, which computes the $\chi_y$ genus of the GLSM with given charge matrix, dimension vector and stability parameter. The list of stable flags whose contributions are non-zero is stored in \fun{JKRelevantFlags}, and the list of the corresponding contributions to the $\chi_y$ genus is stored in \fun{JKChiGenus}.}

\defn{JKIndexSplit}{\vardef{ChargeMatrix},\vardef{Nvec},\vardef{Etavec},\vardef{SplitNodes}}{standalone routine, which computes the $\chi_y$ genus of the GLSM with given charge matrix, dimension vector and stability parameter, using Cauchy's formula to split the vector multiplet determinants associated to the nodes listed in \var{SplitNodes}. \cite{Beaujard:2019pkn}.}

\subsection{Constructing the integrand and extracting the residue}

\defn{ZEuler}{\vardef{ChargeMatrix},\vardef{Nvec}}{computes the integrand in the residue formula for the Euler number}
 
\defn{ZRational}{\vardef{ChargeMatrix},\vardef{Nvec}}{constructs the integrand in the residue formula for the $\chi_y$ genus in rational representation}

\defn{ZTrig}{\vardef{ChargeMatrix},\vardef{Nvec}}{constructs the integrand in the residue formula for the $\chi_y$ genus in trigonometric representation}

\defn{ZElliptic}{\vardef{ChargeMatrix},\vardef{Nvec}}{constructs the integrand in the residue formula for the elliptic genus}


\defn{ListPermutationsWithMultiplicity}{\vardef{Nvec}}{computes the list of all multi-partitions of \var{Nvec}, represented by a standard permutation, and their multiplicity}

\defn{PartitionMultiplicity}{\vardef{pa}}{computes the multiplicity of a partition in Cauchy-Bose formula}

\defn{ZEulerPartial}{\vardef{ChargeMatrix},\vardef{Nvec},\vardef{ListPerm}}{constructs the partial contribution to the integrand in the residue formula for the index, corresponding to the list of (possibly empty) permutations associated to each node \var{Listperm}.}

\defn{ZTrigPartial}{\vardef{ChargeMatrix},\vardef{Nvec},\vardef{ListPerm}}{constructs the partial contribution to the integrand in the residue formula for the $\chi_y$ genus in trigonometric representation, corresponding to the list of (possibly empty) permutations associated to each node \var{Listperm}}

\defn{ZRationalPartial}{\vardef{ChargeMatrix},\vardef{Nvec},\vardef{ListPerm}}{constructs the partial contribution to the integrand in the residue formula for the $\chi_y$ genus in rational representation, corresponding to the list of (possibly empty) permutations associated to each node \var{Listperm}}

\defn{ZEllipticPartial}{\vardef{ChargeMatrix},\vardef{Nvec},\vardef{ListPerm}}{constructs the partial contribution to the integrand in the residue formula for the elliptic genus in rational representation, corresponding to the list of (possibly empty) permutations associated to each node \var{Listperm}}


\defn{JKResidueRat}{\vardef{Flags},\vardef{f}}{extracts the sum of the residues of \var{f} (in rational representation) at the specified Flags, weighted with sign; the first entry in \var{Flags} is the intersection point, the second is a list of r-plets of charges for each flag}

\defn{JKResidueTrig}{\vardef{Flags},\vardef{f}}{extracts the sum of the residues of \var{f} (in trigonometric representation) at the specified Flags, weighted with sign; the first entry in \var{Flags} is the intersection point, the second is a list of r-plets of charges for each flag}

%\defn{JKIndexEulerFromStableFlags}{\vardef{ChargeMatrix},\vardef{Nvec},\vardef{ListStableFlags}}{computes the Euler index from the specified list of stable flags}
%
%\defn{JKIndexRefinedFromStableFlags}{\vardef{ChargeMatrix},\vardef{Nvec},\vardef{ListStableFlags}}{computes the $\chi_y$ genus (in rational representation) from the specified list of stable flags}
%
%\defn{JKIndexTrigFromStableFlags}{\vardef{ChargeMatrix},\vardef{Nvec},\vardef{ListStableFlags}}{computes the $\chi_y$ genus (in trigonometric representation) from the specified list of stable flags}
%
%\defn{JKIndexEllipticFromStableFlags}{\vardef{ChargeMatrix},\vardef{Nvec},\vardef{ListStableFlags}}{computes the elliptic genus from the specified list of stable flags}

\subsection{Enumerating stable flags}

\defn{FindSingularities}{\vardef{ChargeMatrix}}{constructs the list of singular hyperplanes for the specified charge matrix. Each item is itself a list containing the intersection point and a list of extended charges associated to the hyperplanes meeting at that point.}

\defn{FindIntersection}{\vardef{Sing}}{computes the intersection points of the hyperplanes listed in \var{Sing}; this may include points on the cylinder, which contribute to the $\chi_y$ genus but not to the Euler number ! Ultimately, this will be generalized for the computation of the elliptic genus to include all points on the torus.  }

\defn{ListHyperplanesIntersectingAt}{\vardef{ListSings},\vardef{Inter}}{collects all the hyperplanes in \var{ListSings} which intersect at \var{Inter}}

\defn{TestProjectiveIntersection}{\vardef{ListSings},\vardef{Inter}}{tests if the intersection point \var{Inter} of the list of hyperplanes \var{ListSings} is projective}

\defn{CollectHyperplanes}{\vardef{ListInterrplets},\vardef{Inter}}{collects all the hyperplanes from \var{ListInterrplets}, which intersect at the point \var{Inter}}

\defn{TestStableFlag}{\vardef{ListHyper},\vardef{Flag},\vardef{Etavec}}{tests if the flag \var{Flag} constructed out of the hyperplanes in \var{ListHyper} is stable with respect to \var{Etavec}; returns ${\rm sign}(\det\kappa)$ if it is stable, 0 otherwise.}

\defn{FindStableFlags}{\vardef{Inter},\vardef{ListSing},\vardef{Nvec},\vardef{Etavec}}{constructs the list of stable flags with stability parameter \var{Etavec} from the specified list of singular hyperplanes intersecting at \var{Inter}. Each item in the output is a list containing the intersection point, a list of basis vectors, the reduced charge matrix and the $\kappa$ matrix.}

\defn{SameFlagQ}{\vardef{Q1},\vardef{Q2}}{tests if the flags \var{$Q_1$} and \var{$Q_2$} (represented by square charge matrices) are equivalent}

\defn{FindStableDomains}{\vardef{Inter},\vardef{ListSing},\vardef{Nvec},\vardef{Etavec}}{
Construct all the  flags  from the specified list of singular hyperplanes intersecting at \var{Inter},
and compute their stability domain. Each item in the  output is  a list containing the intersection point, 
the ordered hyperplanes defining the flag, and the stability condition. Unlikethe routine 
\fun{FindStableFlags}, no attempt is made to eliminate equivalent flags.}

\defn{FindDegrees}{\vardef{ListSings},\vardef{NumSing}}{constructs a list of singularities and their degree, combining the poles from \var{ListSings} with the zeros from the list of hyperplanes \var{NumSing} }


%\defn{TestStableFlag}{\vardef{Listhyper},\vardef{Flag},\vardef{Etavec}}{Tests if 
%\var{Flag} is stable for the list of hyperplanes \var{Listhyper} and stability  parameter \var{Etavec}.}


\subsection{Conversion and visualisation}

\defn{FlagToHyperplanes}{\vardef{Flag}}{translates the flag \var{Flag}, given as r-plet of charge vectors, into a list of linear combinations of Cartan variables taken from \var{JKListuDisplay}}

\defn{PartitionToPermutation}{\vardef{pa}}{translates the partition \var{pa} into a standard permutation}

\defn{PermutationToPartition}{\vardef{perm}}{translates the standard permutation \var{perm} into a partition}

\defn{DisplayFlagList}{\vardef{ListFlags},\vardef{ListDegrees}}{Displays the list of flags in human-readable form. The first column gives the intersection point, the second the list of hyperplanes associated to the basis vectors, the third colum gives ${\rm sign}(\det\kappa)$, the third column gives True if the intersection is projective, False otherwise; the last column gives the degree of the pole.}

\defn{DisplaySingList}{\vardef{ListSings}}{Displays the list of singularities in human-readable form. The first column gives the intersection point, the second the list of hyperplanes intersecting at that point, and the last columns gives True if the intersection is projective, False otherwise.}

\defn{DisplayFlagTree}{\vardef{f}}{Displays the tree associated to flag \var{f}, using node positions and labels defined in \fun{JKVertexCoordinates} and \fun{JKVertexLabels}, which is preset by \fun{JKInitialize}.}

\subsection{Constructing charge matrices}

\defn{ChargeMatrixFromQuiver}{\vardef{Mat},\vardef{RMat},\vardef{Nvec}}{constructs the charge matrix for a quiver with DSZ matrix \var{Mat}, R-charge matrix \var{RMat}, and dimension vector \var{Nvec}; the last two columns are the R-charge and multiplicity. Do not forget to set $\var{JKFrozenCartan}=\{\{1,1\}\}$ to decouple the overall $U(1)$. For non-quiver gauge theories, \var{ChargeMatrix} must be provided by hand.}

\defn{FlavoredRMatrix}{\vardef{Mat}}{Constructs a matrix of R-charges with generic flavor potentials $\theta_i$, assuming no oriented closed loop}

\defn{AbelianSubQuiver}{\vardef{Mat},\vardef{RMat},\vardef{Cvec},\vardef{Nvec},\vardef{perm}}{Constructs the DSZ matrix, R-charge matrix  and FI parameters for the Abelian quiver associated to the list of permutations \var{perm}
in $\prod_{i=1}^K \Sigma_{N_i}$}

\defn{CompleteChargeMatrix}{\vardef{ChargeMatrix},\vardef{Nvec}}{constructs the extended charge matrix consisting of chiral multiplets and vector multiplets}

\defn{PartialChargeMatrix}{\vardef{ChargeMatrix},\vardef{Nvec},\vardef{perm}}{constructs the extended charge matrix consisting of chiral multiplets and vector multiplet contributions associated to the permutations perm}

\defn{CompleteChargeNumMatrix}{\vardef{ChargeMatrix},\vardef{Nvec}}{constructs the extended charge matrix for the numerators, including both chiral multiplets and vector multiplets}

\defn{PartialChargeNumMatrix}{\vardef{ChargeMatrix},\vardef{Nvec},\vardef{perm}}{constructs the extended charge matrix for the numerators, consisting of chiral multiplets and vector multiplet contributions associated to unsplit nodes (in which case  the permutation is empty)}

\defn{LegCharge}{\vardef{Nvec},\vardef{i1},\vardef{s1},\vardef{i2},\vardef{s2}}{constructs a charge vector with 1 in position $(i_1,s_1)$ and $-1$ in position $(i_2,s_2)$}

\defn{TrimChargeTable}{\vardef{ChargeMatrix}}{removes the last two columns and frozen entries in charge matrix, corresponding to the R-charge and multiplicity.}


%\defn{JKIndexEulerSplitFromStableFlags}{\vardef{ChargeMatrix},\vardef{Nvec},\vardef{ListStableFlags}}{computes the Euler index from the specified list of all stable flags}
%
%\defn{JKIndexRefinedSplitFromStableFlags}{\vardef{ChargeMatrix},\vardef{Nvec},\vardef{ListStableFlags}}{computes the $\chi_y$ genus (in rational representation) from the specified list of all partial stable flags}
%
%\defn{JKIndexTrigSplitFromStableFlags}{\vardef{ChargeMatrix},\vardef{Nvec},\vardef{ListStableFlags}}{computes the $\chi_y$ genus (in trigonometric representation) from the specified list of all partial stable flags}
%
%\defn{JKIndexEllipticSplitFromStableFlags}{\vardef{ChargeMatrix},\vardef{Nvec},\vardef{ListStableFlags}}{computes the elliptic genus  from the specified list of all partial stable flags}








\section{Flow tree formula}
Note: starting with version 6.1, following a suggestion of S. Mozgovoy we no longer perturb the DSZ matrix but only the stability parameters. Moreover, by default the flow tree formula uses an optimized
algorithm which only keeps contributions of splittings $\gamma=\gamma_L+\gamma_R$ with 
$\langle\gamma_L,\gamma_R\rangle>0$.

\defn{FlowTreeFormula}{\vardef{Mat},\vardef{Cvec},\vardef{Nvec}}{computes the index of a quiver with DSZ matrix \var{Mat}, stability parameters \var{Cvec} and dimension vector \var{Nvec} in terms of attractor indices, using the formula \cite[(2.21)]{Alexandrov:2018iao}}

\defn{FlowTreeFormulaRat}{\vardef{Mat},\vardef{Cvec},\vardef{Nvec},\vardef{y}}{computes the rational index of a quiver with DSZ matrix \var{Mat}, stability parameters \var{Cvec} and dimension vector \var{Nvec} in terms of rational attractor indices}


\defn{TropicalVertex}{\vardef{m},\{\vardef{n1},\vardef{n2}\},\vardef{LiOm1},\vardef{LiOm2}}{computes the index $\Omega(n_1 \gamma_1+n_2 \gamma_2)$ for an outgoing ray created by scattering of 2 vectors $\gamma_1, \gamma_2$ with Dirac product $m>0$, assuming that $\Omega(p \gamma_1,y)$ is given by the $p$-th entry in \var{LiOm1}, and similarly for $\gamma_2$}.



\defn{TreePoincarePolynomialRat}{\vardef{gam},\newdefy}{expresses the rational BPS index in terms of terms of attractor indices and tree index}

\defn{TreePoincarePolynomial}{\vardef{gam},\newdefy}{expresses the BPS index in terms of terms of attractor indices and tree index}

\defn{EvalTreeIndex}{\vardef{Mat},\vardef{Cvec},\vardef{f}}{evaluates any \var{Treeg[Li,y]} appearing in \var{f} using \fun{TreeIndexOpt} with arguments computed from the full DSZ matrix \var{Mat} and the stability parameters \var{Cvec}; if \var{\$QuiverFlowTreeOpt} <3, \fun{EvalTreeIndex} instead
calls \fun{TreeIndex}}

\defn{TreeIndexOpt}{\vardef{Mat},\vardef{Cvec},\newdefy}{computes the tree index by summing all planar binary trees with $\langle\gamma_L,\gamma_R\rangle>0$ at each vertex, after perturbing
the stability parameters}

\defn{TreeIndexRecursive}{\vardef{Mat},\vardef{Cvec},\vardef{Nvec},\newdefy}{recursively constructs
the sum over planar binary trees with leaves decorated by basis vectors summing up to \var{Nvec}.}

\defn{TreeIndex}{\vardef{Mat},\vardef{Cvec},\newdefy}{computes the tree index by summing all partial tree indices computed using \fun{TreeF}}

\defn{TreeF}{\vardef{Mat},\vardef{Cvec}}{computes the partial tree index by summing over stable planar trees using \fun{PlaneTreeSign}}

\defn{PlaneTreeSign}{\vardef{Mat},\vardef{Cvec},\vardef{Li}}{computes the contribution to the partial tree index from the grouping \var{Li} recursively}

\defn{TreeFAlt1}{\vardef{Mat},\vardef{Cvec}}{computes the partial tree index by summing over stable planar trees using the first alternative recursion in  \cite[(2.64)]{Alexandrov:2018iao}. Will be
used by \fun{TreeIndex} if  \var{\$QuiverOpt} is set to 1.}

\defn{TreeFAlt1Att}{\vardef{Mat}}{computes  the attractor contribution to the partial tree index appearing in the first alternative recursion in  \cite[(2.64)]{Alexandrov:2018iao} }


\defn{TreeFAlt2}{\vardef{Mat},\vardef{Cvec}}{computes the partial tree index by summing over stable planar trees using the second alternative recursion in  \cite[(2.64)]{Alexandrov:2018iao}. Will be
used by \fun{TreeIndex} if  \var{\$QuiverOpt} is set to 2.}

\defn{TreeFAlt2Att}{\vardef{Mat}}{computes  the attractor contribution to the partial tree index appearing in the second alternative recursion in  \cite[(2.64)]{Alexandrov:2018iao} }

\defn{PlaneTreeSplitList}{\vardef{n}}{constructs all splittings of $\{1,\dots, n\}$ appearing in the alternative recursions for the partial tree index}


\defn{DSZProdAbelian}{\vardef{Mat},\vardef{Li1},\vardef{Li2}}{computes the DSZ product for two vectors labelled by list of vertices}

\defn{SubDSZAbelian}{\vardef{Mat},\vardef{Li}}{computes the DSZ matrix $\gamma_{ij}$ for the subquiver labelled by a list of vertices}

\defn{SubFIAbelian}{\vardef{Mat},\vardef{Li}}{computes the stability parameters $c_i$ for the subquiver labelled by a list of vertices (formerly called \fun{SubCvecAbelian})}

\defn{OmAttToOmAttb}{\vardef{f}}{expresses any $\Omega_*(\gamma,y)$ in $f$
 in terms of $\bar\Omega_*(\gamma,y)$'s} 

\defn{OmAttbToOmAtt}{\vardef{f}}{expresses  any $\bar\Omega_*(\gamma,y)$ in $f$
 in terms of $\Omega_*(\gamma,y)$'s}

\defn{NonAbelianFlowTreeFormula}{\vardef{Mat},\vardef{Cvec},\vardef{Nvec}}{computes the rational index of a quiver with DSZ matrix \var{Mat}, stability parameters \var{Cvec} and dimension vector \var{Nvec} in terms of rational attractor indices, using the general (non-necessarily primitive) wall-crossing formula at each wall of marginal stability.}

\defn{ListFirstWalls}{\vardef{Mat},\vardef{Cvec},\vardef{Nvec}}{gives the list of relevant walls 
$W_{\gamma_L,\gamma_R}$ for the non-Abelian flow tree formula for $\bOm(\gamma,z)$, as a list of $\{ \{ \gamma_L,n_L\}, , \{ \gamma_R,n_R\}\}$ such that $\gamma=n_L \gamma_L+n_R \gamma_R$ where $\gamma_L,\gamma_R$ are primitive vectors and $n_L, n_R$ positive integers.}

\defn{BinarySplits}{\vardef{Nvec}}{gives the list of dimension vectors $\gamma_L$ less than $\gamma$, quotiented by the equivalence relation $\gamma_L \to \gamma-\gamma_L$.}


\section{Attractor Tree formula}
%This implements the Attractor Tree formula from \cite{BPMozgovoy}. Just like the Flow Tree formula,
%this computes the index for any stability parameters in terms of attractor indices, but it does not rely on perturbing the DSZ matrix.

\defn{AttractorTreeFormula}{\vardef{Mat},\vardef{Cvec},\vardef{Nvec}}{computes the index of a quiver with DSZ matrix \var{Mat}, stability parameters \var{Cvec} and dimension vector \var{Nvec} in terms of attractor indices.}

\defn{AttractorTreeFormulaRat}{\vardef{Mat},\vardef{Cvec},\vardef{Nvec}}{computes the rational index of a quiver with DSZ matrix \var{Mat}, stability parameters \var{Cvec} and dimension vector \var{Nvec} in terms of rational attractor indices}

\defn{AttractorIndex}{\vardef{Mat},\vardef{Cvec},\newdefy }{evaluates the Attractor index $g_{Sch}(\{\alpha_1,\cdots $ $\alpha_n\};$ $\{\dx_1,\cdots \dx_n\},y)$ 
                   with DSZ products $\alpha_{ij}=\var{Mat}[[i,j]]$, possibly rescaled by an overall factor of 
                   \var{{\tt \$QuiverMultiplier}}, 
                   FI terms $\dx_i=\var{Cvec}[[i]]$, angular momentum fugacity \var{y}, as a sum over rooted  trees with valency greater or equal to 3.
                   }

\defn{EvalAttractorIndex}{\vardef{Mat},\vardef{Cvec},\vardef{f} }{evaluates
any $\var{Treeg[Li,y]}$ appearing in $\var{f}$ as $\var{AttractorIndex[\var{Mat2},\var{Cvec2},y]}$, where $\var{Mat2},\var{Cvec2}$ are computed from the list of vectors $\var{Li}$ and the quiver data $\var{Mat},\var{Cvec}$. }

\defn{AttractorF}{\vardef{Li},\vardef{Mat},\vardef{Cvec}}{computes the partial Attractor index by summing over Attractor trees; the first argument supplies the list of vertices in each Attractor tree, constructed once and for all by \fun{AttractorIndex} using \fun{AttractorTreeVertices}.}

\defn{Attractorg}{\vardef{Mat},\vardef{Cvec}}{computes the sign factor assigned to a given
vertex in a Attractor tree, using the prescription from  \cite[(3.23)]{Alexandrov:2019rth}, $({\rm sign}(0))^m \to 1/(m+1)$ if $m$ is even, or zero if $m$ is odd. If second argument missing, uses
attractor stability condition instead.}

\defn{AttractorTreeList}{\vardef{n}}{constructs the list of rooted planar trees with valency greater or equal to 3, as a list of groupings (parenthesizings) of $\{1,\dots, n\}$.}

\defn{AttractorTreeVertices}{\vardef{t}}{For a given Attractor tree represented as
a grouping $\var{t}$ of the list $\{1,\dots, n\}$, constructs the list of $\{ {\rm vertex}, \{ {\rm children} \} \}$, with the last one in the list being for the root vertex. }


\defn{AttractorTreeTriples}{\vardef{t}}{For a given Attractor tree represented as
a grouping $\var{t}$ of the list $\{1,\dots, n\}$, constructs the list of $\{ {\rm left vertex},  {\rm right vertex},  {\rm parent} \}$. Used by \fun{AttractorTreeVertices} to construct the list of vertices. }

\defn{OmAttNoLoopToZero}{\vardef{Mat},\vardef{f}}{sets to zero any $\Omega_*$  
                  factor in \var{f} corresponding to subquivers without loop, assuming DSZ products
                  $\alpha_{ij}=\var{Mat}[[i,j]]$
                  ; active only on 2-node subquivers if \var{{\tt \$QuiverTestLoop}} is set to False
                  }

\defn{SimplifyOmAttbasis}{\vardef{f}}{replaces  $\Omega_*(\gamma,y)\to 1$ when $\gamma$ is a basis vector, and $\Omega_*(\gamma,y)\to 0$ is $\gamma$ is a multiple of a basis vector; 
}  


\section{Joyce formula}
The Joyce formula relates  rational invariants for two stability conditions:
\be
\label{JSformula}
\bOm(\gamma,\zeta_2,y,t) = 
%\sum_{n\geq 1} 
\sum_{\gamma=\sum_{i=1}^n\gamma_i}
\frac{g_{\rm Joyce}(\{\gamma_i\},\zeta_1,\zeta_2,y)}{|{\rm Aut}\{\gamma_i\}|}
\prod_{i=1}^n \bOm(\gamma_i,\zeta_1,y,t)
\ee
where
\be
\label{defgJoyce}
g_{\rm Joyce}(\{\gamma_i\}, \zeta_1,\zeta_2,y) := \frac{(-1)^{n-1}}{(y-1/y)^{n-1}} \sum_{\sigma\in S_n} 
(-y)^{\sum_{i<j} {\langle \gamma_{\sigma(i)}, \gamma_{\sigma(j)\rangle}}} U(\{\gamma_{\sigma(i)}\},\zeta_1,\zeta_2)
\ee
The extent of the validity of this formula, beyond the simple wall-crossing case considered in \cite{Manschot:2010qz}, is not yet clear to the author.

\medskip

\defn{JoyceFormula}{\vardef{Mat},\vardef{Cvec1},\vardef{Cvec2},\vardef{f}}{
replaces all $\bOm(\gamma,y)$ and $\gR(\gamma,y)$ in \var{f}, all assumed to refer to stability 
\var{Cvec1}, with their corresponding values at \var{Cvec2}, using the formula \eqref{JSformula}
or its analogue for stack invariants (formerly called \fun{JoyceSongFormula});
}


\defn{JoyceIndex}{\vardef{Mat},\vardef{Li},\vardef{Cvec1},\vardef{Cvec2},\vardef{y}}
{computes the index 
$g_{\rm Joyce}(\{\gamma_i\}, \zeta_1,\zeta_2) $ defined in 
\eqref{defgJoyce}.}


\defn{UFactor}{\vardef{Li},\vardef{Cvec1},\vardef{Cvec2}}{computes the factor $U(\{\gamma_i\},\zeta_1,\zeta_2)$ defined in \cite[\S 4]{joyce2008configurations}, using stability condition defined by \fun{Slope}
}

\defn{SFactor}{\vardef{Li},\vardef{Cvec1},\vardef{Cvec2}}{computes the  factor $S(\{\gamma_i\},\zeta_1,\zeta_2)$ defined in \cite[\S 4]{joyce2008configurations}, using stability condition defined by \fun{Slope}
}

\defn{LFactor}{\vardef{Mat},\vardef{Li},\vardef{y}}{computes the  factor $\mathcal{L}(\{\gamma_i\})$ defined in \cite[(5.4)]{Manschot:2010qz}
}

\defn{JoyceIndexAlt}{\vardef{Mat},\vardef{Li},\vardef{Cvec1},\vardef{Cvec2},\vardef{y}}
{computes the index 
$g_{\rm Joyce}(\{\gamma_i\}, \zeta_1,\zeta_2,y) $ defined using the naive extension
of  \cite[(5.5)]{Manschot:2010qz} to $y\neq 1$}


\defn{Slope}{\vardef{Nvec}, \vardef{Cvec}}{computes the slope $\sum N_i \zeta_i$.}

\defn{PartitionToInvervals}{\vardef{pa}}{maps an ordered integer partition of $N$ into a set $0<a_1<\dots <a_m=N$ such that $(a_{j-1}+1,\dots,a_{j})$ label the $j$-th part.}

\defn{CodeToLabeledTreeAlt}{\vardef{li}}{constructs the labelled tree with Pr\"ufer code \var{li},
substitute for \fun{CodeToLabeledTree} in Combinatorica package}

\defn{DTSpectrumFromOmAtt}{\vardef{Mat},\vardef{Cvec},\vardef{Nvec}}{computes all rational invariants with dimension vector less or equal to \var{Nvec}; the result is a list of replacement rules 
$\{\var{Omb[gam_,y_]} :> \bOm(\gamma,\zeta,y) \}$}

\defn{TrivialStackInvariant}{\vardef{Mat},\vardef{Cvec},\vardef{Nvec}}{computes the stack invariant
$G_{\rm Higgs}(\gamma,0,y,t)$ for dimension vector $\gamma=\var{Nvec}$ and 
trivial stability condition, in terms of the rational invariants 
$\bOm(\alpha_i,\zeta,y)$ for stability $\zeta=\var{Cvec}$}


\defn{GaugeMotive}{\vardef{Nvec},\vardef{y}}{computes the motive $\prod_i \left( y^{2N_i^2} \prod_{j=1}^{N_i} (1-y^{-2j})\right)$
of the gauge group $\prod_i GL(N_i,\mathbb{C})$}



\section{Non-commutative Donaldson-Thomas invariants}

\defn{ListKnownBraneTilings}{}{lists the names of brane tilings already coded in the package. The data for each can be extracted from the corresponding item in the global variable \var{BraneTilingsData}}

\defn{NCDTSeriesFromOmS}{\vardef{Mat}, \vardef{Framing}, \vardef{Nmin},\vardef{Nmax}}{constructs the generating function of NCDT invariants for the quiver with DSZ matrix 
$\var{Mat}$ and framing $\var{Framing}$ using the  Coulomb branch formula, for dimension
vectors $\var{Nmin}$ up to $\var{NMax}$. Here $\var{Framing}$ is a vector
of integers $f_i$, giving the total number of arrows $q_i^\alpha:\infty\to i$ (when $f_i>0$), or
from $p_i^\beta:i\to \infty$ (when $f_i<0$)  } 

\defn{NCDTSeriesFromOmAtt}{\vardef{Mat}, \vardef{Framing}, \vardef{Nmin},\vardef{Nmax}}{constructs the generating function of NCDT invariants for the quiver with DSZ matrix 
$\var{Mat}$ and framing $\var{Framing}$ using the Flow Tree formula, for dimension
vectors  $\var{Nmin}$ up to $\var{NMax}$. Here $\var{Framing}$ is a vector
of integers $f_i$, giving the total number of arrows $q_i^\alpha:\infty\to i$ (when $f_i>0$), or
from $p_i^\beta:i\to \infty$ (when $f_i<0$)  } 

\defn{UnrefinedSeriesFromCrystal}{\vardef{hMat}, \vardef{fMat},\vardef{Nn}}{constructs the generating function of unrefined NCDT invariants for the quiver with height matrix 
$\var{hMat}$ and framing data $\var{fMat}$ using 
the Quiver Yangian algorithm, for dimension
vectors with height up to $\var{Nn}$. Here $\var{fMat}$ is a list of two elements: the first is
a matrix of weights $h(q_i^\alpha)$  of arrows $q_i^\alpha:\infty\to i$, and the second is  
a matrix of weights $h(p_i)$  of arrows $p_i^\beta:\infty\to i$. The result is a generating series 
of Laurent polynomials in $y$,
which reduces to the unrefined DT invariants at $y=1$, and to the number of molten crystals at $y=-1$. Here $y$ is {\it not} a refinement parameter !}

\defn{NCDTSeriesFromCrystal}{\vardef{hMat}, \vardef{fMat},\vardef{theta}, \vardef{phi}, \vardef{Nmax}}{constructs the generating function of refined NCDT invariants for the quiver with height matrix 
$\var{hMat}$ and framing data $\var{fMat}$ using 
the refined Quiver Yangian algorithm with $\mathbb{C}^\times_{\theta,\phi}$ action, for dimension
vectors with height up to $\var{NMax}$. Here $\var{fMat}$ is a list of two elements: the first is
a matrix of weights $h(q_i^\alpha)$  of arrows $q_i^\alpha:\infty\to i$, and the second is  
a matrix of weights $h(p_i)$  of arrows $p_i^\beta:\infty\to i$. }

\defn{D6Framing}{\vardef{hMat},\vardef{i}}{constructs the framing data \var{fMat} for a D6-brane associated to node $i$, with only one arrow $q_i:\infty\to i$} 

\defn{D4Framing}{\vardef{hMat},\vardef{i}}{constructs the framing data \var{fMat} for a non-compact D4-brane associated to the $k$-th arrow $i\to j$,  with one arrow $q_i:\infty\to i$,
one arrow $p_j:j \to \infty$ and superpotential $W=W_0+ p_j \Phi_{ij}^k q_i$} 

\defn{FramedDSZ}{\vardef{Mat},\vardef{Framing}}{starting from a quiver with DSZ matrix $\var{Mat}$, constructs the DSZ matrix of the framed quiver with $f_i$ arrows from the framing node (labelled 0) to the node $i$.} 

\defn{FramedFI}{\vardef{Nvec}}{constructs a random FI parameter for a framed quiver with dimension vector $[1;\var{Nvec}]$, with first entry much larger than the other ones.}

\defn{BondFactor}{\vardef{hMat},\vardef{i},\vardef{j},\vardef{z}}{evaluates the bond factor $\varphi^{i\Rightarrow j}(z)$ in the notations of \cite{Li:2020rij}, where $\var{hMat}$ is a matrix
whose $(i,j)$-entry is the list of heights of the arrows from node $i$ to node $j$. The heights
are in turn linear combinations of parameters $h_1,h_2,h_3$.}


\defn{ChargeFunction}{\vardef{hMat},\vardef{fMat}, \vardef{Crys}, \vardef{i}, \vardef{z}}
{constructs the charge function $\Psi_{\cC}^i(z)$ for the molten crystal $\cC=\var{Crys}$ in the notations of \cite{Li:2020rij}. The crystal $\cC$ is encoded in a list of $\{ {\rm color}, {\rm height} \}$ 
for each atom.}

\defn{AddToCrystal}{\vardef{hMat}, \vardef{fMat}, \vardef{i}, \vardef{Crys}}{
Starting from the molten crystal $\var{Crys}$, apply the Quiver Yangian algorithm
to construct the  list of molten crystals with one additional atom of color $i$.}


\defn{GrowCrystalList}{\vardef{hMat}, \vardef{fMat}, \vardef{CrysList}}{
starting from the list of molten crystals $\var{CrysList}$, apply the Quiver Yangian algorithm
to construct the larger list of molten crystals with up to one additional atom of any color.}

\defn{CrystalDim}{\vardef{r},\vardef{Crys}}{computes the dimension vector of the
crystal $\var{Crys}$, assuming that the colors can take values $1$ up to $r$.}

\defn{CrystaWeight}{\vardef{hMat}, \vardef{fMat}, \vardef{theta},  \vardef{phi},  \vardef{Crys}}
{computes the power of $y$ associated to the molten crystal $\var{Crys}$, using the $\mathbb{C}^\times$ action specified by the angles $(\theta,\phi)$. The default case $\theta=0$ corresponds to a  
$\mathbb{C}^\times$ action that preserves the superpotential.}

\defn{DirectedSign}{\vardef{theta},  \vardef{phi},  \vardef{lambda}}
{computes the sign of $\cos\theta ( \lambda_1 \cos\phi +  \sin\phi \lambda_2) + 
\sin\theta \lambda_3$, where $\lambda=\lambda_1 h_1 + \lambda_2 h_2 + \lambda_3 h_3$,
used by \fun{CrystalWeight}}


\defn{EulerNorm}{\vardef{hMat},\vardef{Nvec}}{Computes the Ringel-Tits norm of the dimension
vector $\var{Nvec}$ from the matrix $\var{hMat}$}

\defn{PlotTiling}{\vardef{hMat},\vardef{Nn}, \vardef{v}, \vardef{Range},\vardef{Shor},\vardef{Perf}}{produces a 2D plot of the brane tiling defined by the matrix $\var{hMat}$, by iterating the arrows $\var{Nn}$ times, removing those which belong to the perfect matching $\var{Perf}$. The 
argument \var{v} should be a list of 
2D vectors $\{\var{v1},\var{v2}\}$ determining the vector $v$ associated to an 
arrow with weight $x_1 h_1 + x_2 h_2 + x_3 h_3$, according to $v=x_1 v_1+x_2 v_2$. The plot 
range is set to \var{Range} and arrows are shortened by \var{Shor}. If the argument $\var{Perf}$ is omitted, all arrows are included. The vertices are labelled from $1$ to $K$, unless specified by 
\var{\$QuiverVertexLabels} } 

\defn{PlotTiling3D}{\vardef{hMat},\vardef{Nn}, \vardef{v},  \vardef{Range},\vardef{Perf}}{produces a 3D plot of the Calabi-Yau crystal defined by the matrix $\var{hMat}$, by iterating the arrows $\var{Nn}$ times, removing those which belong to the perfect matching $\var{Perf}$. The  argument \var{v} should be a list of 3D vectors $\{\var{v1},\var{v2},\var{v3}\}$ determining the vector $v$ associated to an 
arrow with weight $x_1 h_1 + x_2 h_2 + x_3 h_3$, according to $v=x_1 v_1+x_2 v_2+x_3v_3$. 
The plot range is set to \var{Range}. If the argument $\var{Perf}$ is omitted, all arrows are included.} 

\defn{PlotToricFan}{\vardef{Fan}}{produces a produces a 2D plot of the polygon with vertices listed in \var{Fan}}

\defn{ListPerfectMatchings}{\vardef{Wp},\vardef{Wm}}{produces the list of cuts for the potential $W=W_+-W_-=\var{Wp}-\var{Wm}$; each term in $W_\pm$ must be a sum of monomials in $\var{Phi[i,j,k]}$ with unit coefficient; each perfect matching is represented by a list of triplets $\{i,j,k\}$
such that $W$ is linear in each $\var{Phi[i,j,k]}$}


\defn{HeightMatrixToDSZ}{\vardef{hMat}}{computes the DSZ matrix associated to the height matrix \var{hMat}}

\defn{HeightMatrixFromPotential}{\vardef{Wp},\vardef{Wm},\{\vardef{i1},\vardef{j1},\vardef{k1}\},
\{\vardef{i2},\vardef{j2},\vardef{k2}\}}{construct the matrix of heights \var{hMat} 
such that the arrow 
$\Phi_{i_1,j_1}^{k_1}$ has height $h_1$,the arrow 
$\Phi_{i_2,j_2}^{k_2}$ has height $h_2$  and all monomials in the potential $W=\var{Wp}-\var{Wm}$ have height $h_3$}


\section{Index from deformed Denef equations}
In \cite{Beaujard:2021fsk}, a procedure was proposed for computing the index of Abelian quivers with (or without) oriented loops by summing over solutions to the `deformed Denef equations'
\be
\label{Denefdef0}
\forall i,\quad \sum_{j\neq i} 
\frac{\kappa_{ij}}{|z_i-z_j- \frac{\pi \Im z}{\beta} R_{ij}  |} 
 =2\zeta_i
\ee
This is implemented in the following routines (due to G. Beaujard):

\defn{ExtendedCoulombIndex}{\vardef{Mat}, \vardef{PMat}, \vardef{RMat}, \vardef{Cvec}, \vardef{r},\vardef{y}}
{computes the index of an Abelian quiver with (or without) oriented loops by summing over solutions to \eqref{Denefdef0}, and computing the contribution of each by residue calculus. The result is a list of contributions associated to the various cluster shapes.}

\defn{CoulombIndexResidue}{\vardef{ListSol},\vardef{Mat}, \vardef{RMat},\vardef{r},\vardef{y}}
{computes the contributions of each collinear solution in \var{ListSol} by evaluating the 
 residues of ione-loop determinant of chiral fields at suitable poles.}


\defn{FindCollinearSolutions}{\vardef{Mat}, \vardef{PMat}, \vardef{RMat}, \vardef{Cvec}, \vardef{r}}
{numerically solves the deformed Denef equations with adjacency matrix \var{Mat} (perturbed to \var{PMat}), R-charges \var{RMat}, stability parameters \var{Cvec} and deformation parameter $\var{r}=\pi \Im z/\beta$. The algorithm goes through all possible signs of $z_i-z_j- \frac{\pi \Im z}{\beta} R_{ij}  $, uses Mathematica \fun{NSolve} function and checks that the resulting solutions are consistent with assumed signs. The result is a list of solutions $\{ \{z_i\to\dots\}, \sigma \}$ where $\sigma$ is the sign of the Hessian around the corresponding solution.}

\defn{ListClusters}{\vardef{ListPos},\vardef{r}}
{produces a list of lists (or clusters) of indices $i$ such that the positions $z_i=\var{ListPos}[[i]]$ have relative square distances less than $|\var{r}|$ in each cluster. }

\defn{CoulombBranchFormulaNum}{\vardef{Mat}, \vardef{PMat}, \vardef{RMat}, \vardef{Cvec}, \vardef{Nvec},\vardef{r},\vardef{y}}
{computes the index of a non-Abelian quiver with (or without) oriented loops by summing over solutions to \eqref{Denefdef0}, and computing the contribution of each by residue calculus. The result is a list of contributions associated to the various cluster shapes. The algorithm is less robust
than for Abelian quivers.}


\defn{CoulombBranchResidue}{\vardef{Mat}, \vardef{PMat}, \vardef{RMat}, \vardef{Cvec}, \vardef{Nvec},\vardef{r},\vardef{y}}
{computes the index of a non-Abelian quiver with (or without) oriented loops by summing over solutions to \eqref{Denefdef0}, and computing the contribution of each by residue calculus. The result is a list of contributions associated to the various cluster shapes.}




\section{Utilities}

\defn{PlotQuiver}{\vardef{Mat}}{Displays the quiver with DSZ matrix \var{Mat}. If the entries in \var{Mat}  are lists of integers, then \var{Mat} is interpreted as the height matrix and the quiver is drawn accordingly. The vertices are labelled from $1$ to $K$, unless specified by 
\var{\$QuiverVertexLabels} } 

\defn{QuiverPlot}{\vardef{Mat}}{Displays the quiver with DSZ matrix \var{Mat} (obsolete).} 


\defn{UnitStepWarn}{\vardef{x}}{gives 1 for $x>0$, 0 for $x<0$, and $1/2$ if $x=0$. Produces a warning in this latter case, irrespective of the value of \var{\tt \$QuiverVerbose}. If so, the user
is advised to run the 
computation again with a different random perturbation. For efficiency, this instruction is no longer
used in v2.1, however a warning is still issued if one encounters a Heaviside function 
with zero argument in the evaluation of the Coulomb indices. %bp
}

\defn{GrassmannianPoincare}{\vardef{k},\vardef{n},\newdefy}{computes the Poincar\'e
polynomial of the Grassmannian $G(k,n)$ via Eq. (6.22) in \cite{Manschot:2012rx}.} 

\defn{CyclicQuiverDSZ}{\vardef{Vec}}{constructs the DSZ matrix
for a cyclic quiver with $a_i$ arrows from node $i$ to node $i+1$} 

\defn{CyclicQuiverOmS}{\vardef{Vec},\vardef{t}}{computes the refined single-centered index 
$\OmS(\gamma_1,\dots, \gamma_K,t)$ associated
to a cyclic Abelian quivers with DSZ matrix $\alpha_{i,i+1}=\var{Vec}[[i]]$ via Eq
(4.29) in \cite{Manschot:2012rx}} 

\defn{CyclicQuiverOmAtt}{\vardef{Vec},\vardef{y}}{computes the refined attractor index 
$\Omega_*r(\gamma_1,\dots, \gamma_K,y)$ associated
to a cyclic Abelian quivers with DSZ matrix $\alpha_{i,i+1}=\var{Vec}[[i]]$ via Eq
(4.21) in \cite{Manschot:2012rx}} 

\defn{CyclicQuiverOmAttUnrefined}{\vardef{Vec}}{computes the unrefined attractor index 
$\Omega_*(\gamma_1,\dots, \gamma_K)$ associated
to a cyclic Abelian quivers with DSZ matrix $\alpha_{i,i+1}=\var{Vec}[[i]]$ using a 
generalization of  Eq (E.2)
in \cite{Denef:2007vg}. This is much faster than \fun{CyclicQuiverOmAtt}.} 

\defn{CyclicQuiverTrivialStacky}{\vardef{Vec},\vardef{y}}{computes the stacky invariant associated
to a cyclic Abelian quivers with DSZ matrix $\alpha_{i,i+1}=\var{Vec}[[i]]$ with trivial stability condition via Eq (4.23) in \cite{Beaujard:2021fsk}} 

\defn{DerangementIndex}{\vardef{Vec},\vardef{y}}{
computes the number of derangements of a set of \var{Vec[i]} objects of color $i$, weighted by $y^{n_+-n_-}$ where $n_+/n_-$ are the number of objects which are displaced forward/backward with respect to the standard ordering $11\dots 222\dots K$ \cite{Beaujard:2021fsk}} 


\defn{FIFromZ}{\vardef{Nvec},\vardef{Zvec}}{computes the FI parameters $\{\zeta_i\}$ from the vector of central charges $\var{Zvec}=\{Z_i\}$ and dimension vector $\var{Nvec}=\{N_i\}$ via $\zeta_i = \Im(e^{-i\phi} Z_i)$, where $\phi$ is the argument of $\sum_i N_i Z_i$. The parameters $\zeta_i$ are rounded up to the nearest rational number with denominator less than \var{\tt \$QuiverPerturb1}}

\defn{AttractorFI}{\vardef{Mat},\vardef{Nvec}}{gives the attractor point $\zeta_i^*=-\sum_{j} \gamma_{ij} N_j$}

\defn{QDeformedFactorial}{\vardef{n},\newdefy }{gives the $q$-deformed factorial $[n,y]!$}

\defn{EvalQFact}{\vardef{f}}{evaluates any \var{QFact[n,y]} appearing in \var{f}}

\defn{ExpandTheta}{\vardef{f}}{replaces $\var{Theta}$ and $\var{Eta}$ by their $q$-expansions, truncated at order $\var{\$QuiverMaxPower}$}

\defn{qSeries}{\vardef{f}}{Replaces $\tau$ by $\log q/(2\pi i)$, and Taylor expand around $q=0$ up to order $\var{\$QuiverMaxPower}$}

\defn{SubVectors}{\vardef{Nvec}}{List all positive dimension vectors which are less than $\var{Nvec}$, including the zero vector and $\var{Nvec}$ itself}

\defn{EulerForm}{\vardef{Mat}}{construct the antisymmetric Ringel-Tits form from the intersection matrix $\var{Mat}$ (coincides with the latter if $\var{Mat}$ is antisymmetric)}


\defn{ToPrimitive}{\vardef{Nvec}}{gives the pair $\{\gamma', d\}$ such that $\gamma'$ is primitive, $d\geq 1$ and $\gamma=d \gamma'$}


\defn{ListLoopRCharges}{\vardef{Mat},\vardef{RMat}}{Lists the oriented closed loops and corresponding R-charge}

\defn{TestNoLoop}{\vardef{Mat},\vardef{Li}}{tests if the subquiver associated to the  charge vectors $\var{Li}$ has oriented closed loops}

\defn{RandomDSZWithNoLoop}{\vardef{n},\vardef{kmax}}{generates a random antisymmetric $n\times n$ matrix with off-diagonal entries less than \var{kmax} in absolute value, ensuring that the quiver has no loop}

\defn{RandomDSZWithLoop}{\vardef{n},\vardef{kmax}}{generates a random antisymmetric $n\times n$ matrix with off-diagonal entries less than \var{kmax} in absolute value, ensuring that the quiver has at least one loop}



\defn{RandomFI}{\vardef{Nvec}}{generates a random set of FI parameters $\zeta_i$ between -1 and 1, such that $\sum \zeta_i\, \var{Nvec}[[i]]=0$; (previously called \fun{RandomCvec})}

\defn{FastResidue}{\vardef{f},\{ \vardef{x}, \vardef{x0} \}}{computes the residue of $f$ at $x=x_0$}


\defn{DSZProd}{\vardef{Mat},\vardef{Nvec1}, \vardef{Nvec2}}{computes the Dirac product $\sum \alpha_{ij} N_i^1 N_j^2$}

\defn{ReduceDSZMatrix}{\vardef{Mat},\vardef{Li}}{sets $\var{Mat}[[i,j]]=\var{Mat}[[j,i]]=0$ for all elements $\{i,j\}$ in \var{Li}, and returns the resulting matrix. If $i=j$, then the $i$-th row and column of $\var{Mat}$ are set to 0.}

\defn{HiggsedDSZ}{\vardef{Mat},\vardef{i},\vardef{j}}{starting from a quiver with DSZ matrix 
$\var{Mat}$, constructs the DSZ matrix of the quiver where the node $j$ has been merged with the node $i$. }

\defn{ConnectedQuiverQ}{\vardef{Mat},\vardef{Nvec}}{returns True is the restriction of the quiver 
with DSZ matrix $\var{Mat}$ to the nodes where $\var{Nvec}$ has non-trivial support is connected.}

\defn{PlethysticExp}{\vardef{f},\vardef{Nmax}}{computes the plethystic exponential of $f$, assuming that it is a function of $\var{x[i]}$ and $\var{y}$ only, keeping the first \var{Nmax} terms in the sum.}

\defn{PlethysticLog}{\vardef{f},\vardef{Nmax}}{computes the plethystic logarythm of $f$, assuming that it is a function of $\var{x[i]}$ and $\var{y}$ only,  keeping the first \var{Nmax} terms in the sum.}

\defn{QuiverMultiplierMat}{\vardef{i},\vardef{j}}{Returns $\var{\$QuiverMultiplier}$ if it is a scalar,
or $\var{\$QuiverMultiplier}[[i,j]]$ if $\var{\$QuiverMultiplier}$ is a matrix.} 


\bibliography{combined}
\bibliographystyle{utphys}


\end{document}

